<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DnD Map Editor</title>

    <!-- Material Icons -->
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons+Outlined"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/icon?family=Material+Icons+Round"
      rel="stylesheet"
    />

    <!-- Load Shoelace components -->
    <!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/themes/dark.css"> -->
    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/themes/light.css"
    />

    <!-- Load required Shoelace components -->
    <script type="module">
      import { setBasePath } from "https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/utilities/base-path.js";
      setBasePath(
        "https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/"
      );
    </script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/button/button.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/dialog/dialog.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/drawer/drawer.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/icon/icon.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/input/input.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/tooltip/tooltip.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/tab/tab.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/tab-group/tab-group.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/tab-panel/tab-panel.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/drawer/drawer.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/progress-bar/progress-bar.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/radio/radio.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/radio-group/radio-group.js"
    ></script>
    <script
      type="module"
      src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/checkbox/checkbox.js"
    ></script>

    <script
  type="module"
  src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/select/select.js"
></script>
<script
  type="module"
  src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/option/option.js"
></script>
<script
  type="module"
  src="https://cdn.jsdelivr.net/npm/@shoelace-style/shoelace@2.12.0/cdn/components/range/range.js"
></script>

    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
<!-- Resource Manager-->
<script src="resource-manager.js"></script>
<!-- Texture Manager -->
<script src="texture-manager.js"></script>

<style>
:root {
    --app-height: 100vh;
    --header-height: 48px;
    --sidebar-width: 280px;
    --primary-bg: #1a1a1a;
    --secondary-bg: #2a2a2a;
    --border-color: #3a3a3a;
    --hover-bg: #3a3a3a;
}

body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI";
    background: var(--primary-bg);
    color: #ffffff;
}

.app-container {
    display: grid;
    grid-template-columns: var(--sidebar-width) 1fr;
    grid-template-rows: var(--header-height) 1fr;
    height: var(--app-height);
}

.header {
    grid-column: 1 / -1;
    background: var(--secondary-bg);
    border-bottom: 1px solid var(--border-color);
    padding: 0 16px;
    display: flex;
    align-items: center;
    gap: 16px;
    z-index: 1000;
    position: relative;
    height: var(--header-height);
}

.header-title {
    font-size: 1.1rem;
    font-weight: 500;
    margin-right: auto;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
}

.sidebar {
    background: var(--secondary-bg);
    border-right: 1px solid var(--border-color);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    z-index: 1000;
    position: relative;
    height: 100%;
}

.sidebar-content {
    flex: 0 0 auto;
    overflow-y: auto;
    padding: 16px;
    flex-shrink: 0;
    overflow: hidden;
}

.tool-section {
    margin-bottom: 12px;
    flex-shrink: 0;
}

.tool-section-title {
    font-size: 0.8rem;
    text-transform: uppercase;
    color: #888;
    margin-bottom: 4px;
    padding: 0 8px;
}

.tool-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 4px;
    padding: 0 8px;
}

.tool-button {
    display: flex;
    flex-direction: row;
    align-items: center;
    justify-content: center;
    background: var(--primary-bg);
    border: 1px solid var(--border-color);
    border-radius: 6px;
    padding: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    height: 32px;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    width: 32px;
    position: relative;
}

.tool-button:hover {
    background: var(--hover-bg);
}

.tool-button.active {
    background: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-400);
}

.tool-button sl-icon {
    font-size: 24px;
    margin-bottom: 4px;
}

.tool-button-label {
    font-size: 0.8rem;
    text-align: center;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    user-select: none;
    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
}

.layers-header {
    padding: 16px;
    border-bottom: 1px solid var(--border-color);
    display: flex;
    align-items: center;
    justify-content: space-between;
    flex-shrink: 0;
    background: var(--secondary-bg);
    flex: 0 0 auto;
}

.layers-panel {
    padding: 0;
    display: flex;
    flex-direction: column;
    gap: 0;
    overflow-y: auto;
    border-right: 1px solid #444;
    height: 100%;
    position: relative;
    flex: 1;
    min-height: 0;
    background: var(--secondary-bg);
}

.layer-item {
    background: var(--secondary-bg);
    border-radius: 3px;
    padding: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    flex-shrink: 0;
    margin-bottom: 2px;
    border: 1px solid transparent;
}

.layer-item:hover {
    background: #468e2c;
    border-color: rgb(255, 255, 255);
}

.layer-item.selected {
    background: #505050;
    border: 1px solid #666;
    border-color: rgba(255, 255, 255, 0.2);
}

.layer-item.editing {
    background: #ffffff44;
}

.layer-content {
    display: grid;
    align-items: center;
    gap: 4px;
    grid-template-columns: auto auto 1fr auto;
}

.layer-thumbnail {
    width: 32px;
    height: 32px;
    background: #333;
    border-radius: 2px;
    overflow: hidden;
}

.layer-thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
}

.layer-info {
    flex: 1;
    min-width: 0;
    padding: 0 4px;
}

.layer-name {
    font-weight: 500;
    margin-bottom: 2px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.layer-dimensions {
    font-size: 0.8em;
    color: #e6e6e6;
}

.layer-controls {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.layer-item:hover .layer-controls {
    opacity: 1;
}

.canvas-container {
    position: relative;
    overflow: hidden;
    background: var(--primary-bg);
    z-index: 1;
}

#mainCanvas {
    position: absolute;
    top: 0;
    left: 0;
}

.room-block {
    position: absolute;
    background: rgba(128, 128, 128, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.7);
    transition: all 0.2s ease;
}

.room-block.highlighted {
    background: rgba(128, 128, 255, 0.4);
    border-color: rgba(255, 255, 255, 0.9);
}

.room-block.editing {
    background: rgba(0, 255, 0, 0.2);
    border-color: #4caf50;
}

.room-block .resize-handle {
    position: absolute;
    width: 12px;
    height: 12px;
    background: white;
    border: 1px solid #333;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    cursor: pointer;
}

.tool-button .material-icons {
    font-size: 20px;
    margin-bottom: 0;
    color: #fff;
    margin-right: 8px;
}

.tool-button:hover .material-icons {
    color: var(--sl-color-primary-400);
}

.tool-button.active .material-icons {
    color: white;
}

.tool-button.active .tool-button-label {
    color: white;
}

.room-block.circle-room {
    border-radius: 50%;
}

.room-block .resize-handle.nw {
    top: 0;
    left: 0;
    cursor: nw-resize;
}

.room-block .resize-handle.ne {
    top: 0;
    left: 100%;
    cursor: ne-resize;
}

.room-block .resize-handle.sw {
    top: 100%;
    left: 0;
    cursor: sw-resize;
}

.room-block .resize-handle.se {
    top: 100%;
    left: 100%;
    cursor: se-resize;
}

.room-controls {
    opacity: 0.8;
    transition: opacity 0.2s ease;
}

.room-block:hover .room-controls {
    opacity: 1;
}

.room-controls .material-icons {
    user-select: none;
    transition: transform 0.2s ease;
}

.room-controls .material-icons:hover {
    transform: scale(1.1);
}

sl-dialog::part(base) {
    --sl-panel-background-color: white;
    color: black;
}

sl-input::part(form-control-label) {
    color: black;
}

.polygon-preview {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 1000;
}

.polygon-point {
    position: absolute;
    width: 8px;
    height: 8px;
    background: white;
    border: 1px solid #333;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    pointer-events: none;
}

.polygon-point:first-child {
    background: #4caf50;
    width: 10px;
    height: 10px;
}

.room-block.polygon-room {
    background: none !important;
    border: none !important;
    position: absolute;
    overflow: visible !important;
}

.room-block.polygon-room svg path {
    transition: all 0.2s ease;
}

.room-block.polygon-room:hover svg path {
    fill: rgba(128, 128, 255, 0.4);
    stroke: rgba(255, 255, 255, 0.9);
}

.room-block.polygon-room .polygon-fill {
    transition: all 0.2s ease;
}

.room-block.polygon-room .polygon-hover {
    transition: opacity 0.2s ease;
}

.room-block.polygon-room.highlighted .polygon-hover {
    opacity: 1 !important;
}

.room-block.polygon-room.editing .polygon-fill {
    fill: rgba(0, 255, 0, 0.2);
    stroke: #4caf50;
}

.polygon-vertex {
    opacity: 0.7;
    transition: opacity 0.2s ease;
    pointer-events: none;
    position: absolute;
    width: 8px;
    height: 8px;
    background: white;
    border: 1px solid #333;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    z-index: 2;
}

.room-block.polygon-room.highlighted .polygon-vertex {
    opacity: 1;
}

.room-block.polygon-room .polygon-base {
    transition: all 0.2s ease;
    vector-effect: non-scaling-stroke;
}

.room-block.polygon-room .polygon-highlight {
    transition: opacity 0.2s ease;
}

.room-block.polygon-room.highlighted .polygon-highlight {
    opacity: 1 !important;
}

.room-block.polygon-room.editing .polygon-base {
    fill: rgba(0, 255, 0, 0.2);
    stroke: #4caf50;
}

.room-block.polygon-room .polygon-vertex {
    position: absolute;
    width: 8px;
    height: 8px;
    background: white;
    border: 1px solid #333;
    border-radius: 50%;
    transform: translate(-50%, -50%);
    opacity: 0.7;
    transition: opacity 0.2s ease;
    pointer-events: none;
}

.room-block.polygon-room:hover .polygon-base {
    fill: rgba(128, 128, 255, 0.4);
    stroke: rgba(255, 255, 255, 0.9);
}

.room-block.polygon-room.highlighted .polygon-base {
    fill: rgba(128, 128, 255, 0.4);
    stroke: rgba(255, 255, 255, 0.9);
}

.room-block .room-background {
    transition: all 0.2s ease;
}

.room-block.highlighted .room-background {
    background: rgba(128, 128, 255, 0.4) !important;
    border-color: rgba(255, 255, 255, 0.9) !important;
}

.room-block.circle-room .room-background {
    border-radius: 50%;
}

.room-block.editing .room-background {
    background: rgba(0, 255, 0, 0.2) !important;
    border-color: #4caf50 !important;
}

.map-marker {
    position: absolute;
    width: 32px;
    height: 32px;
    transform: translate(-50%, -50%);
    cursor: pointer;
    z-index: 100;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    pointer-events: all !important;
}

.map-marker .material-icons {
    font-size: 32px;
    filter: drop-shadow(2px 2px 2px rgba(0, 0, 0, 0.5));
}

.map-marker:hover {
    transform: translate(-50%, -50%) scale(1.1);
}

.marker-player-start .material-icons {
    color: #4caf50;
}

.marker-encounter .material-icons {
    color: #f44336;
}

.marker-treasure .material-icons {
    color: #ffd700;
}

.marker-trap .material-icons {
    color: #ff5722;
}

.marker-tooltip {
    position: fixed;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 12px;
    pointer-events: none;
    z-index: 10000;
    white-space: pre-line;
    transform: translate(-50%, -100%);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    min-width: 150px;
    text-align: center;
}

.map-marker.marker-teleport .material-icons {
    color: #9c27b0;
}

.map-marker.highlighted {
    transform: translate(-50%, -50%) scale(1.2);
    filter: brightness(1.3);
}

.map-marker[data-teleport-point="a"] .material-icons {
    color: #2196f3;
}

.map-marker[data-teleport-point="b"] .material-icons {
    color: #ff9800 !important;
}

.map-marker.editing {
    outline: 2px solid #4caf50;
    outline-offset: 2px;
    z-index: 1000;
}

.map-marker.editing .material-icons {
    color: #4caf50;
}

#editMarkerTool.active {
    background: var(--sl-color-primary-600);
    border-color: var(--sl-color-primary-400);
}

#editMarkerTool.active .tool-button-label {
    color: white;
}

.teleport-connection {
    position: absolute;
    height: 2px;
    background: linear-gradient(to right, #2196f3, #ff9800);
    transform-origin: left center;
    pointer-events: none;
    opacity: 0.6;
    z-index: 90;
}

.teleport-connection::after {
    content: "";
    position: absolute;
    width: 6px;
    height: 6px;
    border-radius: 50%;
    right: -3px;
    top: -2px;
    background: #ff9800;
}

.teleport-connection::before {
    left: -3px;
    top: -2px;
    background: #2196f3;
}

.map-marker[data-teleport-point="a"]:hover .material-icons {
    color: #64b5f6;
}

.map-marker[data-teleport-point="b"]:hover .material-icons {
    color: #ffb74d;
}

.map-marker[data-teleport-point].highlighted .material-icons {
    filter: brightness(1.2);
}

.room-block.polygon-room svg {
    pointer-events: none;
    overflow: visible;
}

.map-marker .monster-token {
    transition: all 0.2s ease;
}

.map-marker:hover .monster-token {
    transform: translate(-50%, -50%) scale(1.1);
    box-shadow: 0 0 10px rgba(255, 152, 0, 0.5);
    border-color: #ff9800;
    transition: all 0.2s ease;
}

.map-marker[title] {
    position: relative;
    display: inline-block;
}

.map-marker[title]:hover::after {
    content: attr(title);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 5px 10px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    border-radius: 4px;
    font-size: 12px;
    white-space: pre;
    pointer-events: none;
    z-index: 1000;
}

.marker-tooltip::after {
    content: "";
    position: absolute;
    bottom: -5px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 5px solid rgba(0, 0, 0, 0.9);
}

.monster-token {
    pointer-events: all !important;
    z-index: 100;
}

.layers-list {
    flex: 1 1 auto;
    overflow-y: auto;
    padding: 4px;
    min-height: 0;
    position: relative;
    overflow-x: hidden;
    margin: 0;
    background: var(--secondary-bg);
}

#layersList {
    height: calc(100vh - var(--header-height) - 200px);
    overflow-y: auto;
    padding: 10px;
    flex: 1;
}

.layers-list::-webkit-scrollbar {
    width: 8px;
}

.layers-list::-webkit-scrollbar-track {
    background: var(--secondary-bg);
}

.layers-list::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 4px;
}

.layers-list::after {
    content: "";
    position: absolute;
    bottom: 0;
    left: 0;
    right: 0;
    height: 20px;
    background: linear-gradient(
        to bottom,
        transparent,
        var(--secondary-bg)
      );
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
}

.layers-list:hover::after {
    opacity: 1;
}

#layersList::-webkit-scrollbar {
    width: 8px;
}

#layersList::-webkit-scrollbar-track {
    background: var(--secondary-bg);
}

#layersList::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 4px;
}

.layers-panel::-webkit-scrollbar {
    width: 8px;
}

.layers-panel::-webkit-scrollbar-track {
    background: var(--secondary-bg);
}

.layers-panel::-webkit-scrollbar-thumb {
    background-color: var(--border-color);
    border-radius: 4px;
}

.drawer-3d-view::part(body) {
    padding: 0;
}

.drawer-3d-view::part(panel) {
    background-color: #1a1a1a;
}

.layer-visibility {
    display: flex;
    align-items: center;
    padding: 0 2px;
}

.visibility-toggle {
    font-size: 20px;
    transition: color 0.2s ease;
}

.visibility-toggle:hover {
    color: #2196f3 !important;
}

.tool-button::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    padding: 4px 8px;
    background: rgba(0, 0, 0, 0.8);
    color: white;
    font-size: 12px;
    border-radius: 4px;
    white-space: nowrap;
    opacity: 0;
    visibility: hidden;
    transition: opacity 0.2s ease, visibility 0.2s ease;
    pointer-events: none;
    margin-bottom: 4px;
}

.tool-button:hover::after {
    opacity: 1;
    visibility: visible;
}

.tool-divider {
    height: 1px;
    background: var(--border-color);
    margin: 8px 8px;
    opacity: 0.5;
}

.marker-tools {
    grid-template-columns: repeat(4, 1fr);
}

.room-block.wall-room {
    background: rgba(70, 70, 70, 0.3);
    border: 2px dashed #666;
}

.room-block.wall-room.highlighted {
    background: rgba(70, 70, 70, 0.5) !important;
    border: 2px dashed #888 !important;
}

.room-block.wall-room.editing {
    background: rgba(70, 70, 70, 0.4) !important;
    border: 2px dashed #4caf50 !important;
}

.layer-item.wall-room .layer-name {
    color: #fff;
}

.layer-item.wall-room .layer-name::before {
    content: "🧱";
    margin-right: 4px;
}

.room-block.room-room {
    background: rgba(128, 128, 255, 0.3);
    border: 2px solid rgba(255, 255, 255, 0.7);
}

.room-block[data-texture-room="true"] {
    border: 2px dashed #4caf50;
    background: rgba(76, 175, 80, 0.2);
}

.layer-item .layer-name::before {
    margin-right: 8px;
    font-family: "Material Icons";
    font-size: 20px;
    vertical-align: middle;
}

.layer-item .layer-name {
    display: flex;
    align-items: center;
}

.layer-item[data-room-type="wall"] .layer-name::before {
    content: "grid_4x4";
    color: #757575;
}

.layer-item[data-room-type="room"] .layer-name::before {
    content: "meeting_room";
    color: #2196f3;
}

.layer-item[data-texture-room="true"] .layer-name::before {
    content: "texture";
    color: #4caf50;
}

.layer-item:hover .layer-name::before {
    opacity: 0.8;
    transform: scale(1.1);
    transition: all 0.2s ease;
}

.room-block.circle-room.room-room {
    background: rgba(128, 128, 255, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.7);
}

.room-block.circle-room.room-room.highlighted {
    background: rgba(128, 128, 255, 0.4);
    border: 2px solid rgba(255, 255, 255, 1);
    box-shadow: 0 0 5px rgba(128, 128, 255, 0.5);
}

.room-block.circle-room.wall-room {
    background: rgba(255, 152, 0, 0.2);
    border: 2px solid rgba(255, 255, 255, 0.7);
}

.room-block.circle-room.wall-room.highlighted {
    background: rgba(255, 152, 0, 0.4);
    border: 2px solid rgba(255, 255, 255, 1);
    box-shadow: 0 0 5px rgba(255, 152, 0, 0.5);
}

.room-block.polygon-room.room-room .polygon-base {
    fill: rgba(128, 128, 255, 0.2);
    stroke: rgba(255, 255, 255, 0.7);
    stroke-dasharray: 5,5;
    stroke-width: 2;
}

.room-block.polygon-room.room-room.highlighted .polygon-base {
    fill: rgba(128, 128, 255, 0.4);
    stroke: rgba(255, 255, 255, 1);
    stroke-width: 3;
    filter: drop-shadow(0 0 3px rgba(128, 128, 255, 0.5));
}

.room-block.polygon-room.wall-room .polygon-base {
    fill: rgba(255, 152, 0, 0.2);
    stroke: rgba(255, 255, 255, 0.7);
    stroke-width: 2;
}

.room-block.polygon-room.wall-room.highlighted .polygon-base {
    fill: rgba(255, 152, 0, 0.4);
    stroke: rgba(255, 255, 255, 1);
    stroke-width: 3;
    filter: drop-shadow(0 0 3px rgba(255, 152, 0, 0.5));
}

.map-marker[data-teleport-point="a"] {
    outline: 2px solid #2196f3;
}

.map-marker[data-teleport-point="b"] {
    outline: 2px solid #ff9800;
}

.layer-item.dragging {
    opacity: 0.5;
    transform: scale(0.95);
    background: rgba(255, 255, 255, 0.1);
}

.layer-item.drag-over {
    border-bottom: 2px solid var(--sl-color-primary-600);
}

.layer-folder {
    margin-bottom: 2px;
    background: rgba(255, 255, 255, 0.03);
    border-radius: 3px;
    transition: background-color 0.2s;
}

.folder-header {
    display: flex;
    align-items: center;
    padding: 4px 6px;
    cursor: pointer;
    user-select: none;
}

.folder-header:hover {
    background: rgba(255, 255, 255, 0.1);
}

.folder-toggle {
    margin-right: 4px;
    cursor: pointer;
    opacity: 0.7;
}

.folder-icon {
    margin-right: 8px;
    color: #2196F3;
}

.folder-name {
    flex: 1;
    font-weight: 500;
}

.folder-controls {
    display: flex;
    gap: 8px;
    opacity: 0;
    transition: opacity 0.2s;
}

.folder-header:hover .folder-controls {
    opacity: 1;
}

.folder-content {
    padding-left: 24px;
    min-height: 10px;
    padding: 2px 0 2px 12px;
    transition: background-color 0.2s;
}

.folder-content.drag-over {
    background: rgba(33, 150, 243, 0.1);
}

.folder-header.drag-over {
    background: rgba(33, 150, 243, 0.2);
}

.folder-header .visibility-toggle {
    transition: color 0.2s ease;
}

.folder-hidden {
    opacity: 0.7;
}

.folder-hidden .folder-content {
    opacity: 0.5;
}

.folder-controls, .layer-controls {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s;
}

.material-icons {
    font-size: 18px;
}

.thumbnail-placeholder {
    width: 100%;
    height: 100%;
    background: #444;
    display: flex;
    align-items: center;
    justify-content: center;
}

.thumbnail-placeholder::after {
    content: 'No Preview';
    font-size: 8px;
    color: #666;
}

.layer-item.locked {
    position: relative;
}

.layer-item.locked::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.1);
    pointer-events: none;
}

.layer-item.locked .delete-btn {
    opacity: 0.5;
    cursor: not-allowed;
}

.lock-toggle {
    transition: color 0.2s ease;
}

.lock-toggle:hover {
    color: #f44336 !important;
}

.header sl-button-group {
    min-width: 300px;
    display: flex;
    gap: 4px;
}

.header-title:hover {
    color: var(--sl-color-primary-500);
}

.header-title-edit {
    opacity: 0.5;
    font-size: 16px;
}

.header-title:hover .header-title-edit {
    opacity: 1;
}

.door {
    position: absolute;
    pointer-events: all;
    cursor: pointer;
}

.door-frame {
    border: 2px solid #666;
    background: rgba(102, 102, 102, 0.2);
}

.door-panel {
    position: absolute;
    background: #8b4513;
    transition: transform 0.3s;
}

.door.open .door-panel {
    transform: rotateY(90deg);
}

.map-marker[data-type="door"] {
    width: 24px;
    height: 24px;
    background: #8b4513;
    border: 2px solid #666;
    border-radius: 2px;
    transform-origin: left;
    transition: transform 0.3s;
}

.map-marker[data-type="door"].open {
    transform: rotateY(90deg);
}

.room-block.docked {
    border: 2px solid #ae33c7;
    position: relative;
}

.room-block.docked::after {
    content: "Shift + Drag to dock";
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0,0,0,0.7);
    color: white;
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.2s;
}

.room-block.docked:hover::after {
    opacity: 1;
}

.dock-point {
            position: absolute;
            width: 16px;  
            height: 16px;
            background: #666;
            border: 2px solid #888;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.2s;
        }

        .dock-point:hover {
            background: var(--sl-color-primary-600);
            transform: translate(-50%, -50%) scale(1.2);
        }

        .dock-point.active {
            background: var(--sl-color-primary-600);
            box-shadow: 0 0 0 4px rgba(var(--sl-color-primary-600), 0.3);
        }

        .room-option {
            transition: all 0.2s;
        }

        .room-option:hover {
            background: #444;
        }

        .room-option.selected {
            border-color: var(--sl-color-primary-600);
            background: #333;
        }

        .dock-preview {
    border: 1px solid #444;
    position: relative;
    min-height: 500px;
    background: #2a2a2a;
    border-radius: 4px;
}

.dock-positions {
    height: 100%;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
    padding: 20px;
}

.room-option {
    cursor: pointer;
    padding: 8px;
    margin-bottom: 8px;
    border: 1px solid #666;
    border-radius: 4px;
    transition: all 0.2s ease;
}

.room-option:hover {
    background: #444;
}

.room-option.selected {
    border-color: var(--sl-color-primary-600);
    background: #333;
}

.room-option img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 2px;
}

sl-radio {
    --sl-input-border-color: #666;
    --sl-input-border-color-hover: #888;
    padding: 8px;
    border-radius: 4px;
    transition: background-color 0.2s;
}

sl-radio:hover {
    background-color: rgba(255, 255, 255, 0.1);
}

sl-radio[checked] {
    background-color: rgba(var(--sl-color-primary-500), 0.1);
}

.docked {
    border: 2px solid var(--sl-color-primary-500);
    position: relative;
}

.docked::after {
    content: "Docked";
    position: absolute;
    top: -20px;
    left: 50%;
    transform: translateX(-50%);
    background: var(--sl-color-primary-500);
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 12px;
    opacity: 0;
    transition: opacity 0.2s;
}

.docked:hover::after {
    opacity: 1;
}

.dock-grid {
    aspect-ratio: 1;
    background: #2a2a2a;
    border-radius: 8px;
    padding: 20px;
}

.dock-button {
    all: unset;
    aspect-ratio: 1;
    background: #444;
    border-radius: 4px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 24px;
    transition: all 0.2s;
}

.dock-button:hover {
    background: #666;
}

.dock-button.selected {
    background: var(--sl-color-primary-600);
}

.dock-spacer {
    aspect-ratio: 1;
}

.room-preview {
    aspect-ratio: 1;
    border: 2px solid #666;
    border-radius: 4px;
    overflow: hidden;
}

    </style>
  </head>

  <body>
    <div class="app-container">

      <header class="header">
        <sl-button-group>
            <sl-button size="medium" variant="default" id="openMapBtn">
                <span class="material-icons">folder_open</span>
                Open
            </sl-button>
            <sl-button size="medium" variant="default" id="saveProjectBtn">
                <span class="material-icons">save</span>
                Save
            </sl-button>
            <sl-button size="medium" variant="default" id="resourceManagerBtn" style="display: none;">
                <span class="material-icons">palette</span>
                Res.
            </sl-button>
        </sl-button-group>
    
        <div class="header-title" id="mapTitle">
            <span id="mapTitleText">D&D Map Editor</span>
            <span class="material-icons header-title-edit">edit</span>
        </div>
    
        <sl-button size="medium" variant="primary" id="create3d">
            <span class="material-icons">view_in_ar</span>
            View 3D
        </sl-button>
    </header>

      <aside class="sidebar">
        <div class="sidebar-content">
          <div class="tool-section">
            <div class="tool-section-title">Tools</div>
            <div class="tool-grid">
              <div
                class="tool-button"
                id="selectTool"
                data-tooltip="Rectangle [R]"
              >
                <span class="material-icons">crop_square</span>
              </div>
              <div
                class="tool-button"
                id="circleTool"
                data-tooltip="Circle [C]"
              >
                <span class="material-icons">circle</span>
              </div>
              <div
                class="tool-button"
                id="wallTool"
                data-tooltip="Create Polygon/Wall [W]"
              >
                <span class="material-icons">account_tree</span>
              </div>
            </div>
          </div>

          <div class="tool-divider"></div>

          <div class="tool-section">
            <div class="tool-section-title">Map Markers</div>
            <div class="tool-grid marker-tools">
              <div
                class="tool-button"
                id="playerStartTool"
                data-tooltip="Player Start [S]"
              >
                <span class="material-icons">person_pin_circle</span>
              </div>
              <div
                class="tool-button"
                id="encounterTool"
                data-tooltip="Add Encounter [E]"
              >
                <span class="material-icons">local_fire_department</span>
              </div>
              <div
                class="tool-button"
                id="treasureTool"
                data-tooltip="Add Treasure [T]"
              >
                <span class="material-icons">workspace_premium</span>
              </div>
              <div
                class="tool-button"
                id="trapTool"
                data-tooltip="Add Trap [X]"
              >
                <span class="material-icons">warning</span>
              </div>
              <div
                class="tool-button"
                id="teleportTool"
                data-tooltip="Add Teleport"
              >
                <span class="material-icons">swap_calls</span>
              </div>
              <div class="tool-button" id="doorTool" data-tooltip="Add Door [D]">
                <span class="material-icons">door_front</span>
              </div>
            </div>
          </div>

          <div class="tool-divider"></div>

          <div class="layers-panel">
            <div class="tool-section-title">Rooms</div>
            <div class="layers-list" id="layersList">
              <!-- Room layers will be added here dynamically -->
            </div>
          </div>
        </div>
      </aside>

      <main class="canvas-container">
        <div
          id="canvasWrapper"
          style="position: relative; width: 100%; height: 100%; overflow: auto"
        >
          <canvas id="mainCanvas"></canvas>
        </div>
      </main>
    </div>

    <script>
      function parseMapDimensions(filename) {
        const dimensionMatch = filename.match(/(\d+)x(\d+)/i);
        if (dimensionMatch) {
          return {
            width: parseInt(dimensionMatch[1]),
            height: parseInt(dimensionMatch[2])
          };
        }
        return null;
      }

      function updateLayersListHeight() {
        const sidebar = document.querySelector(".sidebar");
        const sidebarContent = document.querySelector(".sidebar-content");
        const layersHeader = document.querySelector(".layers-header");
        const layersList = document.querySelector("#layersList");

        if (sidebar && sidebarContent && layersHeader && layersList) {
          // Calculate total height of fixed elements
          const toolbarsHeight =
            sidebarContent.offsetHeight + layersHeader.offsetHeight;

          // Calculate remaining height
          const availableHeight = sidebar.offsetHeight - toolbarsHeight;

          // Set the height
          layersList.style.height = `${availableHeight}px`;

          // Log the heights for debugging
        //   console.log({
        //     sidebarHeight: sidebar.offsetHeight,
        //     toolbarsHeight,
        //     availableHeight
        //   });
        }
      }

      class Token {
        constructor(x, y, size, image, type = "monster") {
          this.x = x;
          this.y = y;
          this.size = size || 1;
          this.image = image;
          this.type = type;
          this.height = 2; // Height above ground
        }
      }

      class MonsterManager {
        constructor(mapEditor) {
          this.mapEditor = mapEditor;
          this.monsterDatabase = this.loadDatabase();
          this.baseTokenUrl = "https://5e.tools/img/bestiary/tokens/";
        }

        async storeMonsterImage(imgElement) {
          try {
            // Create a canvas to convert the image
            const canvas = document.createElement("canvas");
            canvas.width = imgElement.naturalWidth;
            canvas.height = imgElement.naturalHeight;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(imgElement, 0, 0);

            // Convert to base64
            const base64Image = canvas.toDataURL("image/webp");
            return base64Image;
          } catch (error) {
            console.error("Error converting monster image:", error);
            return null;
          }
        }

        loadDatabase() {
          try {
            const dbText = localStorage.getItem("monsterDatabase");
            return dbText ? JSON.parse(dbText) : { monsters: {} };
          } catch (e) {
            console.error("Error loading monster database:", e);
            return { monsters: {} };
          }
        }

        async saveMonsterToDatabase(monsterData) {
          const key = monsterData.basic.name.toLowerCase().replace(/\s+/g, "_");
          this.monsterDatabase.monsters[key] = monsterData;
          localStorage.setItem(
            "monsterDatabase",
            JSON.stringify(this.monsterDatabase)
          );
        }

        getTokenUrl(tokenPath) {
          // Clean up any double slashes and ensure proper path construction
          return this.baseTokenUrl + tokenPath.replace(/^\//, "");
        }

        tryStoreToken(tokenUrl) {
    return fetch(tokenUrl, {
        mode: 'cors',
        headers: {
            'Accept': 'image/webp,*/*'
        }
    })
    .then(response => {
        if (!response.ok) throw new Error('Failed to fetch token');
        return response.blob();
    })
    .then(blob => {
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => {
                resolve(reader.result);
            };
            reader.readAsDataURL(blob);
        });
    })
    .catch(error => {
        console.log('Failed to fetch token directly:', error);
        return tokenUrl; // Return URL as fallback
    });
}

        // Complete showMonsterSelector method for MonsterManager class
        async showMonsterSelector(marker) {
          const dialog = document.createElement("sl-dialog");
          dialog.label = "Import Monster";
          dialog.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 16px;">
            <div class="instructions" style="background: #f5f5f5; padding: 12px; border-radius: 4px;">
                <p style="margin-top: 0;">To import monster data from 5e.tools:</p>
                <ol style="margin-left: 20px; margin-bottom: 0;">
                    <li>On 5e.tools, right-click on the monster's stat block</li>
                    <li>Select "Inspect Element" or press F12</li>
                    <li>Find the <code>&lt;div id="wrp-pagecontent"&gt;</code> element</li>
                    <li>Right-click the element and select:
                        <ul style="margin-left: 20px;">
                            <li>In Chrome/Edge: "Copy > Copy element"</li>
                            <li>In Firefox: "Copy > Outer HTML"</li>
                        </ul>
                    </li>
                    <li>Paste below</li>
                </ol>
            </div>
            
            <textarea id="monsterHtml" 
                rows="10" 
                style="width: 100%; font-family: monospace; padding: 8px;"
                placeholder="Paste monster stat block HTML here..."></textarea>

            <div id="monsterPreview" style="display: none; max-height: 60vh; overflow-y: auto;">
                <!-- Basic Info Section -->
                <div class="monster-header" style="margin-bottom: 16px;">
                    <h3 class="monster-name" style="margin: 0; font-size: 1.5em;"></h3>
                    <div style="color: #666; font-style: italic;">
                        <span class="monster-size"></span>
                        <span class="monster-type"></span>,
                        <span class="monster-alignment"></span>
                    </div>
                </div>

                <!-- Monster Image -->
                <div class="monster-image" style="margin-bottom: 16px; text-align: center;">
                    <img style="max-width: 200px; display: none;" />
                </div>

                <!-- Core Stats -->
                <div class="core-stats" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 16px; text-align: center; background: #f5f5f5; padding: 8px; border-radius: 4px;">
                    <div>
                        <div style="font-weight: bold;">Armor Class</div>
                        <div class="monster-ac"></div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">Hit Points</div>
                        <div class="monster-hp"></div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">Speed</div>
                        <div class="monster-speed"></div>
                    </div>
                </div>

                <!-- Ability Scores -->
                <div class="ability-scores" style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-bottom: 16px; text-align: center; background: #f5f5f5; padding: 8px; border-radius: 4px;">
                    <div>
                        <div style="font-weight: bold;">STR</div>
                        <div class="monster-str"></div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">DEX</div>
                        <div class="monster-dex"></div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">CON</div>
                        <div class="monster-con"></div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">INT</div>
                        <div class="monster-int"></div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">WIS</div>
                        <div class="monster-wis"></div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">CHA</div>
                        <div class="monster-cha"></div>
                    </div>
                </div>

                <!-- Additional Traits -->
                <div class="additional-traits" style="margin-bottom: 16px;">
                    <div style="margin-bottom: 8px;">
                        <strong>Challenge Rating:</strong> <span class="monster-cr"></span>
                        (<span class="monster-xp"></span> XP)
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>Proficiency Bonus:</strong> <span class="monster-prof"></span>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>Senses:</strong> <span class="monster-senses"></span>
                    </div>
                    <div style="margin-bottom: 8px;">
                        <strong>Languages:</strong> <span class="monster-languages"></span>
                    </div>
                    <div class="monster-immunities-container" style="margin-bottom: 8px; display: none;">
                        <strong>Immunities:</strong> <span class="monster-immunities"></span>
                    </div>
                </div>
            </div>

            <div id="loadingIndicator" style="display: none; text-align: center;">
                <sl-spinner></sl-spinner>
                <div>Processing monster data...</div>
            </div>

            <div id="errorMessage" style="display: none; color: #f44336;"></div>
        </div>
        <div slot="footer">
            <sl-button variant="neutral" class="cancel-btn">Cancel</sl-button>
            <sl-button variant="primary" class="save-btn" disabled>Save Monster</sl-button>
        </div>
    `;

          document.body.appendChild(dialog);
          dialog.show();

          const htmlInput = dialog.querySelector("#monsterHtml");
          const saveBtn = dialog.querySelector(".save-btn");
          const cancelBtn = dialog.querySelector(".cancel-btn");
          const loadingIndicator = dialog.querySelector("#loadingIndicator");
          const errorMessage = dialog.querySelector("#errorMessage");
          const preview = dialog.querySelector("#monsterPreview");

          let currentMonsterData = null;

          // Handle HTML paste
          htmlInput.addEventListener("input", async () => {
            const html = htmlInput.value.trim();
            if (html) {
              try {
                loadingIndicator.style.display = "block";
                errorMessage.style.display = "none";
                preview.style.display = "none";
                saveBtn.disabled = true;

                // Add await here since parseMonsterHtml returns a Promise now
                currentMonsterData = await this.parseMonsterHtml(html);
                // console.log("Parsed monster data:", currentMonsterData); // Debug log

                if (currentMonsterData) {
                  // Update basic info
                  preview.querySelector(".monster-name").textContent =
                    currentMonsterData.basic.name;
                  preview.querySelector(".monster-size").textContent =
                    currentMonsterData.basic.size;
                  preview.querySelector(".monster-type").textContent =
                    currentMonsterData.basic.type;
                  preview.querySelector(".monster-alignment").textContent =
                    currentMonsterData.basic.alignment;

                  // Update core stats
                  preview.querySelector(".monster-ac").textContent =
                    currentMonsterData.stats.ac;
                  preview.querySelector(
                    ".monster-hp"
                  ).textContent = `${currentMonsterData.stats.hp.average} (${currentMonsterData.stats.hp.roll})`;
                  preview.querySelector(".monster-speed").textContent =
                    currentMonsterData.stats.speed;

                  // Update ability scores
                  Object.entries(currentMonsterData.abilities).forEach(
                    ([ability, data]) => {
                      const element = preview.querySelector(
                        `.monster-${ability}`
                      );
                      if (element) {
                        element.textContent = `${data.score} (${
                          data.modifier >= 0 ? "+" : ""
                        }${data.modifier})`;
                      }
                    }
                  );

                  // Update additional traits
                  preview.querySelector(".monster-cr").textContent =
                    currentMonsterData.basic.cr;
                  preview.querySelector(".monster-xp").textContent =
                    currentMonsterData.basic.xp;
                  preview.querySelector(
                    ".monster-prof"
                  ).textContent = `+${currentMonsterData.basic.proficiencyBonus}`;
                  preview.querySelector(".monster-senses").textContent =
                    currentMonsterData.traits.senses.join(", ") || "None";
                  preview.querySelector(".monster-languages").textContent =
                    currentMonsterData.traits.languages;

                  // Handle immunities
                  const immunitiesContainer = preview.querySelector(
                    ".monster-immunities-container"
                  );
                  const immunitiesSpan = preview.querySelector(
                    ".monster-immunities"
                  );
                  if (currentMonsterData.traits.immunities.length > 0) {
                    immunitiesSpan.textContent =
                      currentMonsterData.traits.immunities.join(", ");
                    immunitiesContainer.style.display = "block";
                  } else {
                    immunitiesContainer.style.display = "none";
                  }



                const imgElement = preview.querySelector(".monster-image img");
if (currentMonsterData.token && (currentMonsterData.token.data || currentMonsterData.token.url)) {
    const imageUrl = currentMonsterData.token.data || currentMonsterData.token.url;
    try {
        const base64Data = await this.tryFetchImage(imageUrl);
        if (base64Data) {
            currentMonsterData.token.data = base64Data;
            console.log("Successfully captured token as base64");
        }
    } catch (error) {
        console.error("Error fetching token:", error);
    }
    
    imgElement.src = imageUrl;
    imgElement.style.display = "block";
} else {
    imgElement.style.display = "none";
}

                  preview.style.display = "block";
                  saveBtn.disabled = false;
                }
              } catch (error) {
                console.error("Error in monster data processing:", error); // More detailed error log
                errorMessage.textContent =
                  "Error parsing monster data. Please check the HTML.";
                errorMessage.style.display = "block";
                saveBtn.disabled = true;
              } finally {
                loadingIndicator.style.display = "none";
              }
            }
          });

          return new Promise((resolve) => {


            saveBtn.addEventListener("click", async () => {
    if (currentMonsterData) {
        // At this point, currentMonsterData.token.data should already have the base64 data
        // from when the preview image loaded
        marker.data.monster = currentMonsterData;
        await this.saveMonsterToDatabase(currentMonsterData);
        this.mapEditor.updateMarkerAppearance(marker);
        dialog.hide();
        resolve(true);
    }
});

            cancelBtn.addEventListener("click", () => {
              dialog.hide();
              resolve(false);
            });

            dialog.addEventListener("sl-after-hide", () => {
              dialog.remove();
            });
          });
        }

        async tryFetchImage(url) {
    try {
        const response = await fetch(url, {
            mode: 'no-cors',
            cache: 'no-cache',
            referrerPolicy: 'no-referrer'
        });
        const blob = await response.blob();
        return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onloadend = () => resolve(reader.result);
            reader.readAsDataURL(blob);
        });
    } catch (error) {
        console.error("Error fetching image:", error);
        return null;
    }
}

        // In MonsterManager class
        async extractMonsterData(url) {
          try {
            // Parse the URL to get monster ID
            const monsterId = url.split("#")[1]; // e.g., "zombie_xphb"
            if (!monsterId) {
              throw new Error("Invalid monster URL format");
            }

            // Since we can't fetch directly from 5e.tools,
            // we'll need the user to paste the monster data section
            const dialog = document.createElement("sl-dialog");
            dialog.label = "Monster Data Import";
            dialog.innerHTML = `
    <div style="display: flex; flex-direction: column; gap: 16px;">
        <div class="instructions">
            <p>To import monster data from 5e.tools:</p>
            <ol style="margin-left: 20px;">
                <li>On 5e.tools, right-click on the monster's stat block</li>
                <li>Select "Inspect Element" or press F12</li>
                <li>Find the <code>&lt;div id="wrp-pagecontent"&gt;</code> element</li>
                <li>Right-click the element and select:</li>
                <ul style="margin-left: 20px;">
                    <li>In Firefox: "Copy > Outer HTML"</li>
                    <li>In Chrome: "Copy > Copy element"</li>
                    <li>In Edge: "Copy > Outer HTML"</li>
                </ul>
                <li>Paste it below</li>
            </ol>
        </div>
        <div class="visual-guide" style="margin-top: 10px; padding: 10px; background: #f5f5f5; border-radius: 4px;">
            <p style="margin: 0 0 10px 0;"><strong>The element should look like this:</strong></p>
            <pre style="background: #fff; padding: 10px; border-radius: 4px; margin: 0; font-size: 0.9em; overflow-x: auto;"><code>&lt;div id="wrp-pagecontent" class="relative wrp-stats-table..."&gt;</code></pre>
        </div>
        <textarea id="monsterHtml" 
                 rows="10" 
                 style="width: 100%; font-family: monospace;"
                 placeholder="Paste monster stat block HTML here..."></textarea>
        <div id="errorMessage" style="display: none; color: #f44336;"></div>
    </div>
    <div slot="footer">
        <sl-button variant="neutral" class="cancel-btn">Cancel</sl-button>
        <sl-button variant="primary" class="import-btn">Import Monster</sl-button>
    </div>
`;

            document.body.appendChild(dialog);
            dialog.show();

            return new Promise((resolve, reject) => {
              const importBtn = dialog.querySelector(".import-btn");
              const cancelBtn = dialog.querySelector(".cancel-btn");
              const errorMsg = dialog.querySelector("#errorMessage");

              importBtn.addEventListener("click", () => {
                const html = dialog.querySelector("#monsterHtml").value;
                try {
                  const monsterData = this.parseMonsterHtml(html);
                  dialog.hide();
                  resolve(monsterData);
                } catch (error) {
                  errorMsg.textContent =
                    "Error parsing monster data. Please check the HTML.";
                  errorMsg.style.display = "block";
                }
              });

              cancelBtn.addEventListener("click", () => {
                dialog.hide();
                reject(new Error("Import cancelled"));
              });

              dialog.addEventListener("sl-after-hide", () => {
                dialog.remove();
              });
            });
          } catch (error) {
            console.error("Error extracting monster data:", error);
            throw error;
          }
        }

        parseMonsterHtml(html) {
        //   console.log("Starting to parse monster HTML"); // Debug 1
          const parser = new DOMParser();
          const doc = parser.parseFromString(html, "text/html");
        //   console.log("HTML parsed into document"); // Debug 2

          try {
            // Required basic information
            const name =
              doc.querySelector(".stats__h-name")?.textContent?.trim() ||
              "Unknown Monster";
            // console.log("Found name:", name); // Debug 3

            const typeInfo =
              doc.querySelector("td i")?.textContent?.trim() ||
              "Medium Unknown, Unaligned";
            // console.log("Found typeInfo:", typeInfo); // Debug 4

            // Parse type info with defaults
            const [sizeTypeAlign = ""] = typeInfo.split(",");
            const [size = "Medium", type = "Unknown"] = sizeTypeAlign
              .trim()
              .split(/\s+/);
            const alignment = typeInfo.split(",")[1]?.trim() || "Unaligned";

            // Required stats (with safe defaults)
            const stats = {
              ac: parseInt(
                doc.querySelector('[title="Armor Class"] + span')
                  ?.textContent || "10"
              ),
              hp: {
                average: parseInt(
                  doc.querySelector('[title="Hit Points"] + span')
                    ?.textContent || "1"
                ),
                roll:
                  doc
                    .querySelector('[data-roll-name="Hit Points"]')
                    ?.textContent?.trim() || "1d4",
                max: parseInt(
                  doc.querySelector('[title="Maximum: "]')?.textContent || "1"
                )
              },
              speed: "30 ft."
            };

            // Try to get actual speed
            const speedNode = Array.from(doc.querySelectorAll("strong")).find(
              (el) => el.textContent === "Speed"
            );
            if (speedNode && speedNode.nextSibling) {
              stats.speed = speedNode.nextSibling.textContent.trim();
            }

            // Parse ability scores - Updated version
            // console.log("About to parse ability scores");
            // Parse ability scores
            const abilities = {};
            const abilityRows = Array.from(
              doc.querySelectorAll(".stats-tbl-ability-scores__lbl-abv")
            );

            abilityRows.forEach((labelCell) => {
              const abilityDiv = labelCell.querySelector(".bold.small-caps");
              if (abilityDiv) {
                const abilityName = abilityDiv.textContent.trim().toLowerCase();
                if (
                  ["str", "dex", "con", "int", "wis", "cha"].includes(
                    abilityName
                  )
                ) {
                  try {
                    // Get score from the next cell's div directly
                    const scoreDiv =
                      labelCell.nextElementSibling.querySelector(
                        ".ve-text-center"
                      );
                    const score = parseInt(scoreDiv?.textContent || "10");

                    // Get modifier from the next cell's roller span
                    const modifierCell =
                      scoreDiv?.parentElement.nextElementSibling;
                    const modifierText =
                      modifierCell?.querySelector(".roller")?.textContent ||
                      "0";
                    const modifier = parseInt(
                      modifierText.match(/[+-]\d+/)?.[0] || "0"
                    );

                    abilities[abilityName] = { score, modifier };
                    // console.log(`Parsed ${abilityName}:`, { score, modifier });
                  } catch (e) {
                    console.error(`Error parsing ${abilityName}:`, e);
                    abilities[abilityName] = { score: 10, modifier: 0 };
                  }
                }
              }
            });
            // console.log("Abilities parsed successfully:", abilities);

            // Optional extras
            let extras = {
              immunities: [],
              resistances: [],
              senses: [],
              languages: "None",
              cr: "0",
              xp: 0,
              proficiencyBonus: 2
            };

            try {
              const crNode = doc.querySelector(
                '[title="Challenge Rating"] + span'
              );
              if (crNode) {
                extras.cr = crNode.textContent.split("(")[0].trim();
                const xpMatch = crNode.textContent.match(/XP (\d+)/);
                if (xpMatch) extras.xp = parseInt(xpMatch[1]);
                // console.log("Parsed CR/XP:", extras.cr, extras.xp);
              }
            } catch (e) {
              console.log("Optional: Failed to parse CR/XP");
            }

            try {
              const immunityNode = Array.from(
                doc.querySelectorAll("strong")
              ).find((el) => el.textContent === "Immunities");
              if (immunityNode && immunityNode.nextSibling) {
                extras.immunities = immunityNode.nextSibling.textContent
                  .split(";")
                  .map((i) => i.trim())
                  .filter((i) => i);
                // console.log("Parsed immunities:", extras.immunities);
              }
            } catch (e) {
              console.log("Optional: Failed to parse immunities");
            }

            try {
              const sensesNode = Array.from(
                doc.querySelectorAll("strong")
              ).find((el) => el.textContent === "Senses");
              if (sensesNode && sensesNode.nextSibling) {
                extras.senses = sensesNode.nextSibling.textContent
                  .split(",")
                  .map((s) => s.trim())
                  .filter((s) => s);
                // console.log("Parsed senses:", extras.senses);
              }
            } catch (e) {
              console.log("Optional: Failed to parse senses");
            }

            try {
              const languagesNode = Array.from(
                doc.querySelectorAll("strong")
              ).find((el) => el.textContent === "Languages");
              if (languagesNode && languagesNode.nextSibling) {
                extras.languages =
                  languagesNode.nextSibling.textContent.trim() || "None";
                // console.log("Parsed languages:", extras.languages);
              }
            } catch (e) {
              console.log("Optional: Failed to parse languages");
            }

            // console.log("Starting token handling");
            // Token handling with proper error handling
            let tokenUrl = null;
            const tokenDiv = doc.querySelector("#float-token");
            if (tokenDiv) {
              const imgElement = tokenDiv.querySelector("img.stats__token");
              if (imgElement && imgElement.src) {
                const path = imgElement.src.replace(
                  /.*\/bestiary\/tokens\//,
                  ""
                );
                tokenUrl = this.getTokenUrl(path);
                // console.log("TokenDiv-Token URL:", tokenUrl); // Debug log
              } else {
                const linkElement =
                  tokenDiv.querySelector("a.stats__wrp-token");
                if (linkElement && linkElement.href) {
                  const path = linkElement.href.replace(
                    /.*\/bestiary\/tokens\//,
                    ""
                  );
                  tokenUrl = this.getTokenUrl(path);
                  console.log("Fallback-Token URL:", tokenUrl); // Debug log
                }
              }

              // If we found a token URL, try to store it
              if (tokenUrl) {
                // console.log("Attempting to store token...");
                return this.tryStoreToken(tokenUrl)
                  .then((tokenData) => {
                    // console.log(
                    //   "Token stored successfully:",
                    //   tokenData ? "data present" : "no data"
                    // );
                    return {
                      basic: {
                        name,
                        size,
                        type,
                        alignment,
                        cr: extras.cr,
                        xp: extras.xp,
                        proficiencyBonus: extras.proficiencyBonus
                      },
                      stats,
                      abilities,
                      traits: {
                        immunities: extras.immunities,
                        senses: extras.senses,
                        languages: extras.languages
                      },
                      token: {
                        url: tokenUrl,
                        data: tokenData
                      }
                    };
                  })
                  .catch((error) => {
                    console.error("Error storing token:", error);
                    // Return data with null token data in case of error
                    return {
                      basic: {
                        name,
                        size,
                        type,
                        alignment,
                        cr: extras.cr,
                        xp: extras.xp,
                        proficiencyBonus: extras.proficiencyBonus
                      },
                      stats,
                      abilities,
                      traits: {
                        immunities: extras.immunities,
                        senses: extras.senses,
                        languages: extras.languages
                      },
                      token: {
                        url: tokenUrl,
                        data: null
                      }
                    };
                  });
              }
            }
            // console.log("Token handling complete");
            // console.log("Returning monster data...");
            // Return data without token if no token URL was found
            return {
              basic: {
                name,
                size,
                type,
                alignment,
                cr: extras.cr,
                xp: extras.xp,
                proficiencyBonus: extras.proficiencyBonus
              },
              stats,
              abilities,
              traits: {
                immunities: extras.immunities,
                senses: extras.senses,
                languages: extras.languages
              },
              token: {
                url: tokenUrl,
                data: null
              }
            };
          } catch (error) {
            console.error("Error parsing monster HTML:", error);
            // Return a minimal valid monster object
            return {
              basic: {
                name: "Unknown Monster",
                size: "Medium",
                type: "Unknown",
                alignment: "Unaligned",
                cr: "0",
                xp: 0,
                proficiencyBonus: 2
              },
              stats: {
                ac: 10,
                hp: { average: 1, roll: "1d4", max: 1 },
                speed: "30 ft."
              },
              abilities: {
                str: { score: 10, modifier: 0 },
                dex: { score: 10, modifier: 0 },
                con: { score: 10, modifier: 0 },
                int: { score: 10, modifier: 0 },
                wis: { score: 10, modifier: 0 },
                cha: { score: 10, modifier: 0 }
              },
              traits: {
                immunities: [],
                senses: [],
                languages: "None"
              }
            };
          }
        //   console.log("Monster HTML parsing complete");
        }

        getStoredToken(monsterId) {
          try {
            const key = `monster_token_${monsterId}`;
            return localStorage.getItem(key);
          } catch (e) {
            console.error("Error retrieving stored token:", e);
            return null;
          }
        }

        cloneEncounter(marker) {
          // Clone an existing encounter marker
          const offset = 50;

          if (marker.type === "encounter" && marker.data.monster) {
            // Get the monster's size and calculate dimensions
            const monsterSize = this.mapEditor.getMonsterSizeInSquares(
              marker.data.monster.basic.size
            );
            const baseSize = 32;
            const scaledSize = baseSize * monsterSize /2 ;

            console.log("Size calculations:", {
              monsterSize,
              baseSize,
              scaledSize
            });

            // Create new marker
            const newMarker = this.mapEditor.addMarker(
              "encounter",
              marker.x + offset,
              marker.y + offset,
              { ...marker.data }
            );

            // Force the correct size
            const tokenElement =
              newMarker.element.querySelector(".monster-token");
            if (tokenElement) {
              const styles = {
                width: `${scaledSize}px !important`,
                height: `${scaledSize}px !important`,
                borderRadius: "10%",
                border: "2px solid #f44336",
                overflow: "hidden",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                position: "absolute",
                left: `-${scaledSize / 2}px`,
                top: `-${scaledSize / 2}px`,
                transformOrigin: "center"
              };

              Object.assign(tokenElement.style, styles);
            }

            // Call updateMarkerAppearance but preserve our size
            this.mapEditor.updateMarkerAppearance(newMarker);

            // Re-apply size after updateMarkerAppearance
            if (tokenElement) {
              tokenElement.style.width = `${scaledSize}px`;
              tokenElement.style.height = `${scaledSize}px`;
              tokenElement.style.left = `-${scaledSize / 2}px`;
              tokenElement.style.top = `-${scaledSize / 2}px`;
            }

            return newMarker;
          } else {
            return this.mapEditor.addMarker(
              marker.type,
              marker.x + offset,
              marker.y + offset,
              { ...marker.data }
            );
          }
        }

        getMonsterTooltip(monster) {
          if (!monster) return "Unlinked Encounter";
          return `
            ${monster.basic.name}
            CR ${monster.basic.cr} (${monster.basic.xp} XP)
            HP: ${monster.stats.hp.average}
            AC: ${monster.stats.ac}
        `;
        }
      }

      // Add this inside your empty script tag
      class Scene3DController {
        constructor() {
          this.clear();
        }

        clear() {
          this.scene = null;
          this.camera = null;
          this.renderer = null;
          this.controls = null;
          this.animationFrameId = null;
          this.isActive = false;
          this.keyHandlers = {
            keydown: null,
            keyup: null
          };
          this.keys = {};
        }

        initialize(container, width, height) {
          // Scene
          this.scene = new THREE.Scene();
          this.scene.background = new THREE.Color(0x222222);

          // Camera
          this.camera = new THREE.PerspectiveCamera(
            75,
            width / height,
            0.1,
            1000
          );
          this.camera.position.set(0, 6, 50); // Adjusted starting position

          // Renderer
          this.renderer = new THREE.WebGLRenderer({ antialias: true });
          this.renderer.setSize(width, height);
          container.appendChild(this.renderer.domElement);

          // Controls
          this.controls = new THREE.PointerLockControls(this.camera, container);

          // Setup key handlers
          this.keyHandlers.keydown = (e) =>
            (this.keys[e.key.toLowerCase()] = true);
          this.keyHandlers.keyup = (e) =>
            (this.keys[e.key.toLowerCase()] = false);

          document.addEventListener("keydown", this.keyHandlers.keydown);
          document.addEventListener("keyup", this.keyHandlers.keyup);

          this.isActive = true;
        }

        cleanup() {
          this.isActive = false;

          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
          }

          if (this.renderer) {
            this.renderer.dispose();
            if (this.renderer.domElement?.parentNode) {
              this.renderer.domElement.parentNode.removeChild(
                this.renderer.domElement
              );
            }
          }

          if (this.controls) {
            this.controls.dispose();
          }

          if (this.keyHandlers.keydown) {
            document.removeEventListener("keydown", this.keyHandlers.keydown);
          }
          if (this.keyHandlers.keyup) {
            document.removeEventListener("keyup", this.keyHandlers.keyup);
          }

          this.clear();
        }
      }

      class Room {
        constructor(id, bounds, name = "", shape = "rectangle", type = "wall") {
          // Default to 'wall'
          this.id = id;
          this.bounds = bounds;
          this.type = name.startsWith("Room") ? "room" : "wall"; // If it starts with 'Room', it's a room, otherwise it's a wall
          this.name = name || `${this.type === "wall" ? "Wall" : "Room"} ${id}`;
          this.shape = shape;
          this.finalized = false;
          this.thumbnail = null;
          this.element = null;
          this.points = bounds.points || null;
          this.isEditing = false;
          this.visible = true;
          this.locked = false;
        }

        toggleVisibility() {
          this.visible = !this.visible;
          if (this.element) {
            this.element.style.display = this.visible ? "block" : "none";
          }
        }

        createDOMElement(editor) {
          const roomElement = document.createElement("div");
          roomElement.id = `room-${this.id}`;
          roomElement.className = `room-block ${this.shape}-room ${this.type}-room`;
          roomElement.style.pointerEvents = "auto";

          // Add position tooltip
          const gridX = Math.floor(this.bounds.x / editor.cellSize);
          const gridY = Math.floor(this.bounds.y / editor.cellSize);
          roomElement.setAttribute(
            "data-tooltip",
            `Grid Position: ${gridX}, ${gridY}`
          );
          // roomElement.style.display = this.visible ? 'block' : 'none';
          // roomElement.style.pointerEvents = 'auto';
        //   console.log(`Creating element for ${this.shape} room`);

          if (this.shape === "polygon" && this.points) {
            // Create SVG element with proper viewBox
            const svg = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "svg"
            );
            svg.setAttribute("width", "100%");
            svg.setAttribute("height", "100%");
            svg.setAttribute(
              "viewBox",
              `0 0 ${this.bounds.width} ${this.bounds.height}`
            );
            svg.style.position = "absolute";
            svg.style.top = "0";
            svg.style.left = "0";
            // svg.style.pointerEvents = "all";
            svg.style.zIndex = "1"; // Ensure SVG is below controls
    svg.style.pointerEvents = "none"; // Allow clicks to pass through


            // Create polygon path using absolute coordinates
            const path = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "path"
            );
            const pathData =
              this.points
                .map((point, index) => {
                  return `${index === 0 ? "M" : "L"} ${point.x} ${point.y}`;
                })
                .join(" ") + " Z";

            path.setAttribute("d", pathData);
            path.setAttribute("class", "polygon-base");
            path.setAttribute("fill", "rgba(128, 128, 128, 0.3)");
            path.setAttribute("stroke", "rgba(255, 255, 255, 0.7)");
            path.setAttribute("stroke-width", "2");
            path.setAttribute("vector-effect", "non-scaling-stroke"); // Maintain stroke width when scaling
            path.style.pointerEvents = "all";

            svg.appendChild(path);
            roomElement.appendChild(svg);

            // Add vertex points using absolute positioning
            this.points.forEach((point, index) => {
              const vertexMarker = document.createElement("div");
              vertexMarker.className = "polygon-vertex";
              vertexMarker.style.cssText = `
                position: absolute;
                left: ${(point.x / this.bounds.width) * 100}%;
                top: ${(point.y / this.bounds.height) * 100}%;
            `;
              roomElement.appendChild(vertexMarker);
            });
          } else {
            // Rest of the code for rectangle/circle rooms...
            const backgroundDiv = document.createElement("div");
            backgroundDiv.className = "room-background";
            roomElement.appendChild(backgroundDiv);
          }

          // Add resize handles (not for polygon)
          // if (this.shape !== 'polygon') {
          ["nw", "ne", "sw", "se"].forEach((pos) => {
            const handle = document.createElement("div");
            handle.className = `resize-handle ${pos}`;
            handle.addEventListener("mousedown", (e) => {
              e.stopPropagation();
              editor.startResizing(this, pos, e);
            });
            roomElement.appendChild(handle);
          });
          // }

          // Add control buttons
          const controls = document.createElement("div");
          controls.className = "room-controls";

          controls.style.position = "absolute";
    controls.style.zIndex = "2"; // Place controls above SVG
    controls.style.pointerEvents = "auto";

          controls.innerHTML = `
        <span class="material-icons confirm-btn"
              style="padding: 4px; background: #4CAF50; color: white; border-radius: 4px; cursor: pointer;">
            check
        </span>
        <span class="material-icons edit-btn"
              style="padding: 4px; background: #2196F3; color: white; border-radius: 4px; cursor: pointer;">
            edit
        </span>
        <span class="material-icons cancel-btn"
              style="padding: 4px; background: #f44336; color: white; border-radius: 4px; cursor: pointer;">
            close
        </span>
    `;

          controls
            .querySelector(".confirm-btn")
            .addEventListener("click", () => {
              editor.finalizeRoom(this);
            });


          controls.querySelector(".edit-btn").addEventListener("click", () => {
            editor.layersPanel.showRenameDialog(this);
          });

          controls
            .querySelector(".cancel-btn")
            .addEventListener("click", () => {
              editor.deleteRoom(this);
            });

          roomElement.appendChild(controls);

          // Add dragging functionality (only for non-polygon or finalized polygon)
          // if (this.shape !== 'polygon' || this.finalized) {
          roomElement.addEventListener("mousedown", (e) => {
            if (
              !e.target.classList.contains("resize-handle") &&
              !e.target.classList.contains("material-icons")
            ) {
              editor.startDragging(this, e);
            }
          });

          roomElement.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    if (!this.isMarkerEditMode) { // Only show if not in marker edit mode
        window.mapEditor.showStructureContextMenu(this, e);
    }
});

          this.element = roomElement;
          this.updateElement();
          return roomElement;
        }

        static createFromSaved(roomData, editor) {
          // Store the current tool
          const previousTool = editor.currentTool;

          // Set tool based on room shape
          switch (roomData.shape) {
            case "circle":
              editor.currentTool = "circle";
              break;
            case "polygon":
              editor.currentTool = "polygon";
              break;
            default:
              editor.currentTool = "rectangle";
          }

          // Create new room instance with saved data
          const room = new Room(
            roomData.id,
            roomData.bounds,
            roomData.name,
            roomData.shape,
            roomData.type // Make sure type is passed here
          );

          if (roomData.points) {
            room.points = roomData.points;
          }

          room.thumbnail = roomData.thumbnail;
          room.finalized = roomData.finalized || false;

          // Use the existing createDOMElement method
          const roomElement = room.createDOMElement(editor);
          room.element = roomElement;

          // Restore previous tool
          editor.currentTool = previousTool;

          return room;
        }



                updateEditState(isEditing) {
            this.isEditing = isEditing;
            if (this.element) {
                if (isEditing) {
                    this.element.classList.add('editing');
                    this.element.style.pointerEvents = 'auto';
                    // Make sure resize handles are enabled
                    this.element.querySelectorAll('.resize-handle').forEach(handle => {
                        handle.style.pointerEvents = 'auto';
                    });
                } else {
                    this.element.classList.remove('editing');
                    this.element.style.pointerEvents = 'none';
                    // Disable resize handles
                    this.element.querySelectorAll('.resize-handle').forEach(handle => {
                        handle.style.pointerEvents = 'none';
                    });
                    // But keep controls interactive
                    const controls = this.element.querySelector('.room-controls');
                    if (controls) {
                        controls.style.pointerEvents = 'auto';
                    }
                }
            }
        }

        updateElement() {
          if (!this.element) return;

          const editor = window.mapEditor;
          if (!editor) return;

          // Calculate position based on scale and offset
          const left = this.bounds.x * editor.scale + editor.offset.x;
          const top = this.bounds.y * editor.scale + editor.offset.y;
          const width = this.bounds.width * editor.scale;
          const height = this.bounds.height * editor.scale;

          // Update element style
          this.element.style.left = `${left}px`;
          this.element.style.top = `${top}px`;
          this.element.style.width = `${width}px`;
          this.element.style.height = `${height}px`;

          // If this is a polygon room, update vertex positions
          if (this.shape === "polygon" && this.points) {
            const vertices = this.element.querySelectorAll(".polygon-vertex");
            vertices.forEach((vertex, index) => {
              const point = this.points[index];
              vertex.style.left = `${(point.x / this.bounds.width) * 100}%`;
              vertex.style.top = `${(point.y / this.bounds.height) * 100}%`;
            });
          }

          // Update appearance based on type and name
          this.element.classList.remove("wall-room", "room-room");
          this.element.classList.add(`${this.type}-room`);

          // Special styling for texture rooms
          if (this.name === "WallTexture" || this.name === "RoomTexture") {
            this.element.style.border = "2px dashed #4CAF50";
            this.element.style.backgroundColor = "rgba(76, 175, 80, 0.2)";
          }
        }

        createThumbnail(canvas) {
          const thumbnailCanvas = document.createElement("canvas");
          thumbnailCanvas.width = 40;
          thumbnailCanvas.height = 40;
          const ctx = thumbnailCanvas.getContext("2d");

          try {
            ctx.clearRect(0, 0, 40, 40);

            if (this.shape === "polygon" && this.points) {
              // Create clipping path for polygon
              ctx.beginPath();
              this.points.forEach((point, index) => {
                const x = (point.x / this.bounds.width) * 40;
                const y = (point.y / this.bounds.height) * 40;
                if (index === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              });
              ctx.closePath();
              ctx.clip();
            } else if (this.shape === "circle") {
              ctx.beginPath();
              ctx.arc(20, 20, 20, 0, Math.PI * 2);
              ctx.clip();
            }

            // Draw the room portion from the base image
            ctx.drawImage(
              window.mapEditor.baseImage,
              this.bounds.x,
              this.bounds.y,
              this.bounds.width,
              this.bounds.height,
              0,
              0,
              40,
              40
            );

            // Add border
            ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
            ctx.lineWidth = 1;
            if (this.shape === "polygon" && this.points) {
              ctx.beginPath();
              this.points.forEach((point, index) => {
                const x = (point.x / this.bounds.width) * 40;
                const y = (point.y / this.bounds.height) * 40;
                if (index === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
              });
              ctx.closePath();
              ctx.stroke();
            } else if (this.shape === "circle") {
              ctx.beginPath();
              ctx.arc(20, 20, 19.5, 0, Math.PI * 2);
              ctx.stroke();
            } else {
              ctx.strokeRect(0, 0, 40, 40);
            }
          } catch (error) {
            console.error("Error creating thumbnail:", error);
            // Fallback thumbnail
            this.createFallbackThumbnail(ctx);
          }

          this.thumbnail = thumbnailCanvas.toDataURL();
        }

        // Add helper method for fallback thumbnails
        createFallbackThumbnail(ctx) {
          ctx.fillStyle = "#666";
          if (this.shape === "polygon" && this.points) {
            ctx.beginPath();
            this.points.forEach((point, index) => {
              const x = (point.x / this.bounds.width) * 40;
              const y = (point.y / this.bounds.height) * 40;
              if (index === 0) ctx.moveTo(x, y);
              else ctx.lineTo(x, y);
            });
            ctx.closePath();
            ctx.fill();
          } else if (this.shape === "circle") {
            ctx.beginPath();
            ctx.arc(20, 20, 20, 0, Math.PI * 2);
            ctx.fill();
          } else {
            ctx.fillRect(0, 0, 40, 40);
          }
          ctx.fillStyle = "#fff";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.font = "10px sans-serif";
          ctx.fillText(this.name, 20, 20);
        }
      }

      class LayersPanel {
        constructor(editor) {
          this.editor = editor;
          this.panel = document.querySelector(".layers-panel");
          this.layersList = document.getElementById("layersList");
          // this.setupPanel();
          this.draggedItem = null;
          this.folders = [];
    this.setupDragAndDrop();
    this.setupFolderControls();
  }

  setupFolderControls() {
    // Add "New Folder" button to the panel header
    const header = document.querySelector('.layers-panel .tool-section-title');
    header.style.display = 'flex';
    header.style.justifyContent = 'space-between';
    header.style.alignItems = 'center';
    
    const newFolderBtn = document.createElement('sl-button');
    newFolderBtn.size = 'small';
    newFolderBtn.innerHTML = '<span class="material-icons">create_new_folder</span>';
    newFolderBtn.style.marginLeft = 'auto';
    newFolderBtn.addEventListener('click', () => this.createNewFolder());
    header.appendChild(newFolderBtn);
  }

  async createNewFolder() {
    const dialog = document.createElement('sl-dialog');
    dialog.label = 'New Folder';
    dialog.innerHTML = `
      <sl-input
        id="folderNameInput"
        label="Folder Name"
        placeholder="Enter folder name"
        required
      ></sl-input>
      <div slot="footer">
        <sl-button variant="neutral" class="cancel-btn">Cancel</sl-button>
        <sl-button variant="primary" class="create-btn">Create</sl-button>
      </div>
    `;

    document.body.appendChild(dialog);

    return new Promise(resolve => {
      const input = dialog.querySelector('#folderNameInput');
      const createBtn = dialog.querySelector('.create-btn');
      const cancelBtn = dialog.querySelector('.cancel-btn');

      const handleCreate = () => {
        const name = input.value.trim();
        if (name) {
          this.addFolder(name);
          dialog.hide();
          resolve(true);
        }
      };

      createBtn.addEventListener('click', handleCreate);
      cancelBtn.addEventListener('click', () => {
        dialog.hide();
        resolve(false);
      });

      input.addEventListener('keydown', e => {
        if (e.key === 'Enter') handleCreate();
        if (e.key === 'Escape') dialog.hide();
      });

      dialog.addEventListener('sl-after-hide', () => {
        dialog.remove();
      });

      dialog.show();
      setTimeout(() => input.focus(), 100);
    });
  }

  addFolder(name) {
    const folder = {
      id: Date.now(),
      name: name,
      expanded: true,
      rooms: []
    };
    this.folders.push(folder);
    this.updateLayersList();
  }

  createFolderElement(folder) {
    const folderElement = document.createElement('div');
    folderElement.className = `layer-folder ${folder.locked ? 'locked' : ''}`;
    folderElement.dataset.folderId = folder.id;
   
    folderElement.innerHTML = `
      <div class="folder-header">
        <span class="material-icons folder-toggle">
          ${folder.expanded ? 'expand_more' : 'chevron_right'}
        </span>
        <span class="material-icons folder-icon">folder${folder.expanded ? '_open' : ''}</span>
        <span class="folder-name">${folder.name}</span>
        <div class="folder-controls">
          <span class="material-icons visibility-toggle" style="cursor: pointer;">visibility</span>
          <span class="material-icons lock-toggle" style="cursor: pointer; color: ${
              folder.locked ? '#f44336' : '#fff'
          };">${folder.locked ? 'lock' : 'lock_open'}</span>
          <span class="material-icons rename-folder">edit</span>
          <span class="material-icons delete-folder">delete</span>
        </div>
      </div>
      <div class="folder-content" style="display: ${folder.expanded ? 'block' : 'none'}">
      </div>
    `;

    const lockToggle = folderElement.querySelector('.lock-toggle');
    lockToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        this.toggleFolderLock(folder);
    });

    // Add event handlers
    const toggle = folderElement.querySelector('.folder-toggle');
    toggle.addEventListener('click', () => {
        console.log("Folder toggle clicked");
        this.toggleFolder(folder);
    });

    // Add visibility toggle event handler
    const visibilityToggle = folderElement.querySelector('.visibility-toggle');
    visibilityToggle.addEventListener('click', (e) => {
        console.log("Visibility toggle clicked for folder:", folder);
        e.stopPropagation();
        this.toggleFolderVisibility(folder);
    });

    const deleteBtn = folderElement.querySelector('.delete-folder');
deleteBtn.addEventListener('click', () => {
    if (folder.locked) {
        this.editor.showLockedMessage();
        return;
    }
    this.deleteFolder(folder);
});

// Also add locked state check to rename
const renameBtn = folderElement.querySelector('.rename-folder');
renameBtn.addEventListener('click', () => {
    if (folder.locked) {
        this.editor.showLockedMessage();
        return;
    }
    this.renameFolder(folder);
});

    return folderElement;
}

toggleFolderLock(folder) {
    folder.locked = !folder.locked;
    
    // Lock/unlock all rooms in the folder
    folder.rooms.forEach(room => {
        room.locked = folder.locked;
        const roomElement = document.getElementById(`room-${room.id}`);
        if (roomElement) {
            if (folder.locked) {
                roomElement.classList.add('locked');
            } else {
                roomElement.classList.remove('locked');
            }
        }
    });

    // Update the folder's appearance
    const folderElement = document.querySelector(`[data-folder-id="${folder.id}"]`);
    if (folderElement) {
        const lockIcon = folderElement.querySelector('.lock-toggle');
        lockIcon.textContent = folder.locked ? 'lock' : 'lock_open';
        lockIcon.style.color = folder.locked ? '#f44336' : '#666';
        folderElement.classList.toggle('locked', folder.locked);
    }

    this.updateLayersList();
}

setupDragAndDrop() {
    this.layersList.addEventListener('dragstart', (e) => {
        if (!e.target.classList.contains('layer-item')) return;
        const roomId = parseInt(e.target.dataset.roomId);
        const room = this.editor.rooms.find(r => r.id === roomId);
        if (room && room.locked) {
            e.preventDefault();
            this.editor.showLockedMessage();
            return;
        }
    this.draggedItem = e.target;
    e.target.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', e.target.dataset.roomId);
  });

  this.layersList.addEventListener('dragend', (e) => {
    if (!e.target.classList.contains('layer-item')) return;
    e.target.classList.remove('dragging');
    this.draggedItem = null;
    this.updateRoomOrder();
  });

  // Update dragover to handle folders
  this.layersList.addEventListener('dragover', (e) => {
    e.preventDefault();
    if (!this.draggedItem) return;

    const folderContent = e.target.closest('.folder-content');
    const folderHeader = e.target.closest('.folder-header');

    // Remove any existing drag-over indicators
    document.querySelectorAll('.drag-over').forEach(el => 
      el.classList.remove('drag-over')
    );

    if (folderContent) {
      // Dragging within a folder
      const afterElement = this.getDragAfterElement(folderContent, e.clientY);
      if (afterElement) {
        folderContent.insertBefore(this.draggedItem, afterElement);
      } else {
        folderContent.appendChild(this.draggedItem);
      }
      folderContent.classList.add('drag-over');
    } else if (folderHeader) {
      // Dragging over a folder header - indicate can drop into folder
      folderHeader.classList.add('drag-over');
    } else {
      // Dragging in root list
      const afterElement = this.getDragAfterElement(this.layersList, e.clientY);
      if (afterElement) {
        this.layersList.insertBefore(this.draggedItem, afterElement);
      } else {
        this.layersList.appendChild(this.draggedItem);
      }
    }
  });

  // Add drop handling for folders
// In the drop handler in setupDragAndDrop:
this.layersList.addEventListener('drop', (e) => {
    e.preventDefault();
    if (!this.draggedItem) return;

    const folderHeader = e.target.closest('.folder-header');
    const folderContent = e.target.closest('.folder-content');
    
    if (folderHeader || folderContent) {
        const folderElement = folderHeader ? 
            folderHeader.closest('.layer-folder') : 
            folderContent.closest('.layer-folder');
        
        const folderId = folderElement.dataset.folderId;
        const folder = this.folders.find(f => f.id === parseInt(folderId));
        
        if (folder) {
            const roomId = parseInt(this.draggedItem.dataset.roomId);
            const room = this.editor.rooms.find(r => r.id === roomId);
            if (room && room.locked) {
        this.editor.showLockedMessage();
        return;
    }
            
            if (room) {
                console.log("Adding room to folder:", {
                    roomId,
                    roomName: room.name,
                    folderId,
                    folderName: folder.name
                });

                // Remove from any other folder first
                this.folders.forEach(f => {
                    f.rooms = f.rooms.filter(r => r.id !== roomId);
                });

                // Add to new folder
                folder.rooms.push(room);
                console.log("Folder rooms after add:", folder.rooms);
            }
        }
        
        this.updateLayersList();
    }

    // Remove drag-over indicators
    document.querySelectorAll('.drag-over').forEach(el => 
        el.classList.remove('drag-over')
    );
});
}

// Update getDragAfterElement to work with folders
getDragAfterElement(container, y) {
  const draggableElements = [...container.querySelectorAll('.layer-item:not(.dragging)')];
  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset) {
      return { offset: offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

  updateRoomOrder() {
    const newOrder = [...this.layersList.querySelectorAll('.layer-item')]
      .map(item => {
        return this.editor.rooms.find(room => room.id === parseInt(item.dataset.roomId));
      })
      .filter(room => room); // Filter out any undefined rooms
    this.editor.rooms = newOrder;
  }
        setupPanel() {
          // Get the existing Add Room button and set up its event listener
          const addRoomBtn = document.getElementById("addRoomBtn");
          if (addRoomBtn) {
            addRoomBtn.addEventListener("click", () =>
              this.editor.startRoomCreation()
            );
          }
        }


        updateLayersList() {
    this.layersList.innerHTML = '';
    
    // Make sure we have folders initialized
    if (!this.folders) {
        this.folders = [];
    }
    
    // Add folders and their contents
    this.folders.forEach(folder => {
        const folderElement = this.createFolderElement(folder);
        this.layersList.appendChild(folderElement);
        
        // Add rooms in this folder's content area
        const folderContent = folderElement.querySelector('.folder-content');
        folder.rooms.forEach(room => {
            const roomElement = this.createLayerItem(room);
            folderContent.appendChild(roomElement);
        });
    });

    // Only show unassigned rooms (not in any folder)
    const unassignedRooms = this.editor.rooms.filter(room => 
        !this.folders.some(folder => folder.rooms.includes(room))
    );
    unassignedRooms.forEach(room => {
        const roomElement = this.createLayerItem(room);
        this.layersList.appendChild(roomElement);
    });
}


  toggleFolder(folder) {
    folder.expanded = !folder.expanded;
    const folderElement = document.querySelector(`[data-folder-id="${folder.id}"]`);
    if (folderElement) {
        const folderContent = folderElement.querySelector('.folder-content');
        const folderIcon = folderElement.querySelector('.folder-icon');
        const folderToggle = folderElement.querySelector('.folder-toggle');
        
        if (folder.expanded) {
            folderContent.style.display = 'block';
            folderIcon.textContent = 'folder_open';
            folderToggle.textContent = 'expand_more';
        } else {
            folderContent.style.display = 'none';
            folderIcon.textContent = 'folder';
            folderToggle.textContent = 'chevron_right';
        }
    }
}

toggleFolderVisibility(folder) {
    console.log("toggleFolderVisibility called with folder:", folder);
    const folderElement = document.querySelector(`[data-folder-id="${folder.id}"]`);
    const folderVisibilityIcon = folderElement.querySelector('.visibility-toggle');
    
    // Get current state
    const anyVisible = folder.rooms.some(room => room.visible);
    console.log("Current visibility state:", { anyVisible, roomCount: folder.rooms.length });
    
    // For each room in the folder, find its visibility toggle and click it
    folder.rooms.forEach(room => {
        console.log("Toggling visibility for room:", room.name);
        // Use the room's own toggle method
        room.visible = !anyVisible;  // Set all to opposite of current state
        if (room.element) {
            room.element.style.display = room.visible ? 'block' : 'none';
            // Update the room's visibility icon
            const roomVisibilityToggle = document.querySelector(`#room-${room.id} .visibility-toggle`);
            if (roomVisibilityToggle) {
                roomVisibilityToggle.textContent = room.visible ? 'visibility' : 'visibility_off';
                roomVisibilityToggle.style.color = room.visible ? '#fff' : '#666';
            }
        }
    });

    // Update folder visibility icon
    folderVisibilityIcon.textContent = anyVisible ? 'visibility_off' : 'visibility';
    folderVisibilityIcon.style.color = anyVisible ? '#666' : '#fff';
}

  async renameFolder(folder) {
    const dialog = document.createElement('sl-dialog');
    dialog.label = 'Rename Folder';
    dialog.innerHTML = `
      <sl-input
        id="folderNameInput"
        label="Folder Name"
        value="${folder.name}"
        required
      ></sl-input>
      <div slot="footer">
        <sl-button variant="neutral" class="cancel-btn">Cancel</sl-button>
        <sl-button variant="primary" class="save-btn">Save</sl-button>
      </div>
    `;

    document.body.appendChild(dialog);

    return new Promise(resolve => {
      const input = dialog.querySelector('#folderNameInput');
      const saveBtn = dialog.querySelector('.save-btn');
      const cancelBtn = dialog.querySelector('.cancel-btn');

      const handleSave = () => {
        const name = input.value.trim();
        if (name) {
          folder.name = name;
          this.updateLayersList();
          dialog.hide();
          resolve(true);
        }
      };

      saveBtn.addEventListener('click', handleSave);
      cancelBtn.addEventListener('click', () => {
        dialog.hide();
        resolve(false);
      });

      dialog.addEventListener('sl-after-hide', () => {
        dialog.remove();
      });

      dialog.show();
      setTimeout(() => input.focus(), 100);
    });
  }

  async deleteFolder(folder) {
    const dialog = document.createElement('sl-dialog');
    dialog.label = 'Delete Folder';
    dialog.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 16px;">
            <div>
                <p>What would you like to do with "${folder.name}" and its contents?</p>
                <p style="color: #666; font-size: 0.9em;">Folder contains ${folder.rooms.length} item${folder.rooms.length !== 1 ? 's' : ''}</p>
            </div>
            
            <sl-radio-group label="Delete Options" name="deleteOption" value="move">
                <sl-radio value="move">Move contents to root and delete folder</sl-radio>
                <sl-radio value="delete">Delete folder and all contents</sl-radio>
            </sl-radio-group>
        </div>
        <div slot="footer">
            <sl-button variant="neutral" class="cancel-btn">Cancel</sl-button>
            <sl-button variant="danger" class="confirm-btn">Delete</sl-button>
        </div>
    `;

    document.body.appendChild(dialog);

    return new Promise(resolve => {
        const confirmBtn = dialog.querySelector('.confirm-btn');
        const cancelBtn = dialog.querySelector('.cancel-btn');
        const radioGroup = dialog.querySelector('sl-radio-group');

        confirmBtn.addEventListener('click', () => {
            const option = radioGroup.value;
            if (option === 'move') {
                // Move contents to root
                folder.rooms.length = 0;
            } else if (option === 'delete') {
                // Delete all contents and their DOM elements
                folder.rooms.forEach(room => {
                    // Remove from editor's rooms array
                    const index = this.editor.rooms.indexOf(room);
                    if (index > -1) {
                        this.editor.rooms.splice(index, 1);
                    }
                    // Remove the DOM element
                    if (room.element) {
                        room.element.remove();
                    }
                    // Get any associated room element by ID and remove it
                    const roomElement = document.getElementById(`room-${room.id}`);
                    if (roomElement) {
                        roomElement.remove();
                    }
                });
            }
            // Remove folder
            this.folders = this.folders.filter(f => f.id !== folder.id);
            this.updateLayersList();
            dialog.hide();
            resolve(true);
        });

        cancelBtn.addEventListener('click', () => {
            dialog.hide();
            resolve(false);
        });

        dialog.addEventListener('sl-after-hide', () => {
            dialog.remove();
        });

        dialog.show();
    });
}

createLayerItem(room) {
    const layerItem = document.createElement('div');
    layerItem.className = `layer-item ${room.type}-room ${
        room.finalized ? '' : 'editing'
    } ${room.id === this.editor.selectedRoomId ? 'selected' : ''} ${
        room.locked ? 'locked' : ''
    }`;
    
    layerItem.draggable = true;
    layerItem.dataset.roomId = room.id;

    layerItem.addEventListener('mousedown', (e) => {
        if (room.locked && e.button === 0) { // Left click only
            e.preventDefault();
            e.stopPropagation();
            this.editor.showLockedMessage();
            return;
        }
    });

          // Add data attributes for room type and texture
          layerItem.setAttribute("data-room-type", room.type);
          if (room.name === "WallTexture" || room.name === "RoomTexture") {
            layerItem.setAttribute("data-texture-room", "true");
          }

          const getTooltipText = (room) => {
            if (room.name === "WallTexture")
              return "Wall Texture Definition - Used for wall surfaces in 3D view";
            if (room.name === "RoomTexture")
              return "Room Texture Definition - Used for room surfaces in 3D view";
            return room.type === "wall" ? "Wall Definition" : "Room Definition";
          };

          // Add tooltip to layer name
          const layerName = layerItem.querySelector(".layer-name");
          if (layerName) {
            layerName.setAttribute("title", getTooltipText(room));
          }


          layerItem.innerHTML = `
        <div class="layer-content">
            <div class="layer-controls">
                <span class="material-icons visibility-toggle" style="cursor: pointer; color: ${
                    room.visible ? '#fff' : '#666'
                };">
                    ${room.visible ? 'visibility' : 'visibility_off'}
                </span>
                <span class="material-icons lock-toggle" style="cursor: pointer; color: ${
                    room.locked ? '#f44336' : '#fff'
                };">
                    ${room.locked ? 'lock' : 'lock_open'}
                </span>
            </div>
<div class="layer-thumbnail">
    ${(() => {
        if (!room.thumbnail) {
            room.createThumbnail();
        }
        return room.thumbnail ? 
            `<img src="${room.thumbnail}" alt="Room thumbnail">` :
            `<div class="thumbnail-placeholder"></div>`;
    })()}
</div>
            <div class="layer-info">
                <div class="layer-name">${room.name}</div>
                <div class="layer-dimensions">${Math.round(room.bounds.width)}×${Math.round(
                    room.bounds.height
                )}</div>
            </div>
            <div class="layer-controls">
                <span class="material-icons edit-btn" style="color: #2196F3; cursor: pointer;">edit</span>
                <span class="material-icons delete-btn" style="color: #f44336; cursor: pointer;">delete</span>
            </div>
        </div>
    `;

    const lockToggle = layerItem.querySelector('.lock-toggle');
    lockToggle.addEventListener('click', (e) => {
        e.stopPropagation();
        if (room.locked) {
            room.locked = false;
            lockToggle.textContent = 'lock_open';
            lockToggle.style.color = '#fff';
            layerItem.classList.remove('locked');
        } else {
            room.locked = true;
            lockToggle.textContent = 'lock';
            lockToggle.style.color = '#f44336';
            layerItem.classList.add('locked');
        }
    });


          // Add hover effect
          layerItem.addEventListener("mouseenter", () => {
            const roomElement = document.getElementById(`room-${room.id}`);
            if (roomElement) {
              roomElement.classList.add("highlighted");
            }
          });

          layerItem.addEventListener("mouseleave", () => {
            const roomElement = document.getElementById(`room-${room.id}`);
            if (roomElement) {
              roomElement.classList.remove("highlighted");
            }
          });

          layerItem.addEventListener("mouseenter", () => {
            const roomElement = document.getElementById(`room-${room.id}`);
            if (roomElement) {
              roomElement.classList.add("highlighted");
              // Force reflow for polygon highlights
              if (room.shape === "polygon") {
                roomElement.style.transform = "translateZ(0)";
              }
            }
          });

          layerItem.addEventListener("mouseleave", () => {
            const roomElement = document.getElementById(`room-${room.id}`);
            if (roomElement) {
              roomElement.classList.remove("highlighted");
              // Reset transform
              if (room.shape === "polygon") {
                roomElement.style.transform = "";
              }
            }
          });

          const visibilityToggle =
            layerItem.querySelector(".visibility-toggle");
          visibilityToggle.addEventListener("click", (e) => {
            e.stopPropagation();
            room.toggleVisibility();
            visibilityToggle.textContent = room.visible
              ? "visibility"
              : "visibility_off";
            visibilityToggle.style.color = room.visible ? "#fff" : "#666";
          });



          layerItem
            .querySelector(".edit-btn")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              if (room.locked) {
        this.editor.showLockedMessage();
        return;
    }
              this.showRenameDialog(room);
            });

          layerItem
            .querySelector(".delete-btn")
            .addEventListener("click", (e) => {
              e.stopPropagation();
              if (room.locked) {
        this.editor.showLockedMessage();
        return;
    }
              this.editor.deleteRoom(room);
            });

          // Add double-click handler for renaming
          layerItem.addEventListener("dblclick", () => {
            this.showRenameDialog(room);
          });

          return layerItem;
        }
        async showRenameDialog(room) {
    const dialog = document.createElement('sl-dialog');
    dialog.label = 'Area Properties';

    // Force type to wall
    room.type = 'wall';
    
    const assignedTextureId = this.editor.resourceManager?.textureAssignments?.get(room.id)?.textureId;
    const wallTextures = this.editor.resourceManager?.resources.textures.walls;
    const hasTextures = wallTextures && wallTextures.size > 0;
    const currentFolder = this.folders.find(folder => folder.rooms.includes(room));

    // Check for legacy texture setting
    const isLegacyTexture = room.name === "WallTexture";

    dialog.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 16px;">
            <sl-input 
                id="roomNameInput" 
                value="${room.name}" 
                label="Area Name"
            ></sl-input>

            <!-- Folder Selection -->
            <sl-select 
                id="folderSelect" 
                label="Folder"
                value="${currentFolder ? currentFolder.id : ''}"
            >
                <sl-option value="">No Folder</sl-option>
                ${this.folders.map(folder => `
                    <sl-option value="${folder.id}">${folder.name}</sl-option>
                `).join('')}
            </sl-select>

            <!-- Texture Selection -->
            ${hasTextures ? `
                <div style="border: 1px solid #444; padding: 12px; border-radius: 4px;">
                    <label>Texture:</label>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; margin-top: 8px;">
                        ${Array.from(wallTextures.entries()).map(([id, texture]) => `
                            <div class="texture-option" data-texture-id="${id}"
                                style="cursor: pointer; border: 2px solid ${assignedTextureId === id ? 'var(--sl-color-primary-600)' : 'transparent'}; 
                                padding: 4px; border-radius: 4px;">
                                <img src="${texture.data}" style="width: 100%; height: 100px; object-fit: cover; border-radius: 2px;">
                                <div style="font-size: 0.8em; text-align: center;">${texture.name}</div>
                            </div>
                        `).join('')}
                    </div>
    </div>

<!-- Raised Block Options -->
<div style="border: 1px solid #444; padding: 12px; border-radius: 4px;">
    <sl-range 
        id="blockHeight" 
        label="Block Height" 
        min="0" 
        max="8" 
        step="1" 
        tooltip="top" 
        value="${room.blockHeight ? Math.round(room.blockHeight * 2) : '0'}"
        help-text="0 = No raised block, 1 = ½ block, 2 = 1 block, etc."
    ></sl-range>
</div>
` : ''}

            <!-- Legacy Wall Texture Option -->
            ${room.shape === 'rectangle' ? `
                <div style="border: 1px solid #444; padding: 12px; border-radius: 4px;">
                    <sl-checkbox id="setAsTexture" ${isLegacyTexture ? 'checked' : ''}>
                        Set as Wall Texture Source
                    </sl-checkbox>
                </div>
            ` : ''}
        </div>
        
<-- Dock/Undock position holder -->
    
    <div slot="footer">
        <sl-button variant="neutral" class="cancel-btn">Cancel</sl-button>
        <sl-button variant="primary" class="save-btn">Save</sl-button>
    </div>
`;


// <div style="margin-top: 16px;">
//     <sl-button class="dock-room-btn" variant="neutral" style="width: 100%;">
//         <span class="material-icons" style="margin-right: 8px;">link</span>
//         Dock to Another Room
//     </sl-button>
// </div>

    document.body.appendChild(dialog);

    return new Promise((resolve) => {
        const nameInput = dialog.querySelector('#roomNameInput');
        const folderSelect = dialog.querySelector('#folderSelect');
        const setAsTextureCheckbox = dialog.querySelector('#setAsTexture');
        const saveBtn = dialog.querySelector('.save-btn');
        const cancelBtn = dialog.querySelector('.cancel-btn');

        const textureOptions = dialog.querySelectorAll('.texture-option');
        textureOptions.forEach(option => {
            option.addEventListener('click', () => {
                textureOptions.forEach(opt => opt.style.border = '2px solid transparent');
                option.style.border = '2px solid var(--sl-color-primary-600)';
                dialog.selectedTextureId = option.dataset.textureId;
            });
        });

//         const blockHeightSlider = dialog.querySelector('#blockHeight');
// if (blockHeightSlider) {
//     // Set initial value if room is a raised block
//     if (room.isRaisedBlock && room.blockHeight) {
//         blockHeightSlider.value = Math.round(room.blockHeight * 2);
//     }

//     blockHeightSlider.addEventListener('sl-input', (e) => {
//         // Update label while sliding
//         const value = parseInt(e.target.value);
//         const height = value / 2;
//         blockHeightSlider.label = `Block Height: ${height} ${height === 1 ? 'block' : 'blocks'}`;
//     });
// }

const blockHeightSlider = dialog.querySelector('#blockHeight');
if (blockHeightSlider) {
    // Set initial value if room is a raised block
    if (room.isRaisedBlock && room.blockHeight) {
        blockHeightSlider.value = Math.round(room.blockHeight * 2);
    }

    blockHeightSlider.addEventListener('sl-input', (e) => {
        // Update label while sliding
        const value = parseInt(e.target.value);
        const height = value / 2;
        blockHeightSlider.label = `Block Height: ${height} ${height === 1 ? 'block' : 'blocks'}`;

        // Handle Prop- naming as slider moves
        const currentName = nameInput.value.trim();
        if (value > 0) {  // If any height is set
            if (currentName.startsWith("Wall")) {
                nameInput.value = currentName.replace("Wall", "Prop");
            } else if (!currentName.startsWith("Prop-")) {
                nameInput.value = `Prop-${currentName}`;
            }
        } else {  // If height is 0
            if (currentName.startsWith("Prop-")) {
                nameInput.value = currentName.substring(5);  // Remove Prop- prefix
            }
        }
    });
}

      const handleSave = () => {
        const newName = nameInput.value.trim();
        if (newName) {
    room.name = setAsTextureCheckbox?.checked ? "WallTexture" : newName;

    // Save raised block settings
    const blockHeight = parseInt(blockHeightSlider.value) / 2;
    room.isRaisedBlock = blockHeight > 0;
    room.blockHeight = room.isRaisedBlock ? blockHeight : undefined;

    if (dialog.selectedTextureId && this.editor.resourceManager) {
        this.editor.resourceManager.assignTextureToStructure(room.id, dialog.selectedTextureId, 'walls');
    }

    // Handle folder assignment
    if (folderSelect.value) {
        this.folders.forEach(folder => {
            folder.rooms = folder.rooms.filter(r => r.id !== room.id);
        });
        const newFolder = this.folders.find(f => f.id === parseInt(folderSelect.value));
        if (newFolder) {
            newFolder.rooms.push(room);
        }
    }

    this.updateLayersList();
    dialog.hide();
    resolve(true);
}
      };

        saveBtn.addEventListener('click', handleSave);
        cancelBtn.addEventListener('click', () => {
            dialog.hide();
            resolve(false);
        });

const dockBtn = dialog.querySelector('.dock-room-btn');
if (dockBtn) {
    dockBtn.addEventListener('click', () => {
        dialog.hide();
        this.showDockDialog(room);
    });
}

const undockBtn = dialog.querySelector('.undock-room-btn');
if (undockBtn) {
    undockBtn.addEventListener('click', () => {
        this.editor.undockRoom(room);
        dialog.hide();
    });
}

        dialog.addEventListener('sl-after-hide', () => dialog.remove());
        dialog.show();
    });
  }



async showDockDialog(room) {
  const dialog = document.createElement('sl-dialog');
    dialog.label = 'Dock Room';
    dialog.style.setProperty('--width', '800px');

    let selectedRoom = null;
    let selectedPosition = null;  // Add this declaration

    const availableRooms = this.editor.rooms.filter(r => 
        r.id !== room.id && !this.editor.dockedRooms.has(r.id)
    );

    dialog.innerHTML = `
    <div style="display: grid; grid-template-columns: 250px 1fr; gap: 16px;">
        <!-- Room List - left side -->
        <div class="room-list" style="border-right: 1px solid #444; padding-right: 16px; overflow-y: auto; max-height: 500px;">
            <div style="margin-bottom: 8px; font-weight: bold;">Available Rooms</div>
            ${availableRooms.map(r => `
                <div class="room-option" data-room-id="${r.id}" style="cursor: pointer; padding: 8px; margin-bottom: 8px; border: 1px solid #666; border-radius: 4px;">
                    <div style="font-weight: bold; margin-bottom: 4px;">${r.name}</div>
                    <div style="width: 100%; height: 80px; background: #333; border-radius: 2px; overflow: hidden;">
                        ${r.thumbnail ? `<img src="${r.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;">` : ''}
                    </div>
                </div>
            `).join('')}
        </div>

        <!-- Docking Grid - right side -->
        <div class="dock-grid" style="display: grid; grid-template-columns: repeat(5, 1fr); gap: 4px; padding: 20px;">
            <!-- Row 1 -->
            <div class="dock-spacer"></div>
            <button class="dock-button" data-position="top-left">⬆</button>
            <button class="dock-button" data-position="top-center">⬆</button>
            <button class="dock-button" data-position="top-right">⬆</button>
            <div class="dock-spacer"></div>

            <!-- Row 2 -->
            <button class="dock-button" data-position="left-top">⬅</button>
            <div class="dock-spacer"></div>
            <div class="dock-spacer"></div>
            <div class="dock-spacer"></div>
            <button class="dock-button" data-position="right-top">➡</button>

            <!-- Row 3 (Center) -->
            <button class="dock-button" data-position="left-middle">⬅</button>
            <div class="dock-spacer"></div>
            <div class="room-preview">
                <img src="${room.thumbnail}" style="width: 100%; height: 100%; object-fit: cover;">
            </div>
            <div class="dock-spacer"></div>
            <button class="dock-button" data-position="right-middle">➡</button>

            <!-- Row 4 -->
            <button class="dock-button" data-position="left-bottom">⬅</button>
            <div class="dock-spacer"></div>
            <div class="dock-spacer"></div>
            <div class="dock-spacer"></div>
            <button class="dock-button" data-position="right-bottom">➡</button>

            <!-- Row 5 -->
            <div class="dock-spacer"></div>
            <button class="dock-button" data-position="bottom-left">⬇</button>
            <button class="dock-button" data-position="bottom-center">⬇</button>
            <button class="dock-button" data-position="bottom-right">⬇</button>
            <div class="dock-spacer"></div>
        </div>
    </div>


        <div slot="footer">
            <sl-button variant="neutral" class="cancel-btn">Cancel</sl-button>
            <sl-button variant="primary" class="dock-btn" disabled>Dock</sl-button>
        </div>
    `;

    document.body.appendChild(dialog);

return new Promise((resolve) => {
    let selectedRoom = null;
    let selectedPosition = null;

    // Room selection
    dialog.querySelectorAll('.room-option').forEach(option => {
        option.addEventListener('click', () => {
            console.log('Room selected:', option.dataset.roomId);
            dialog.querySelectorAll('.room-option').forEach(opt => 
                opt.classList.remove('selected'));
            option.classList.add('selected');
            selectedRoom = availableRooms.find(r => 
                r.id === parseInt(option.dataset.roomId));
            dialog.querySelector('.dock-btn').disabled = !(selectedRoom && selectedPosition);
            console.log('Dock button state:', {
                selectedRoom: !!selectedRoom,
                selectedPosition: !!selectedPosition,
                buttonDisabled: dialog.querySelector('.dock-btn').disabled
            });
        });
    });

    // Position selection using grid buttons
    dialog.querySelectorAll('.dock-button').forEach(button => {
        button.addEventListener('click', () => {
            console.log('Position selected:', button.dataset.position);
            dialog.querySelectorAll('.dock-button').forEach(btn => 
                btn.classList.remove('selected'));
            button.classList.add('selected');
            selectedPosition = button.dataset.position;
            dialog.querySelector('.dock-btn').disabled = !(selectedRoom && selectedPosition);
            console.log('Dock button state:', {
                selectedRoom: !!selectedRoom,
                selectedPosition: !!selectedPosition,
                buttonDisabled: dialog.querySelector('.dock-btn').disabled
            });
        });
    });

    // Dock button handler
    dialog.querySelector('.dock-btn').addEventListener('click', () => {
        if (selectedRoom && selectedPosition) {
            this.editor.dockRooms(room, selectedRoom, selectedPosition);
            dialog.hide();
            resolve(true);
        }
    });

    // Cancel button handler
    dialog.querySelector('.cancel-btn').addEventListener('click', () => {
        dialog.hide();
        resolve(false);
    });

    dialog.addEventListener('sl-after-hide', () => dialog.remove());
    dialog.show();
});

}

}


      class MapEditor {
constructor() {
    this.canvas = document.getElementById("mainCanvas");
    this.ctx = this.canvas.getContext("2d");
    this.scene3D = new Scene3DController();
    this.rooms = [];
    this.baseImage = null;
    this.scale = 1;
    this.offset = { x: 0, y: 0 };
    this.isDragging = false;
    this.isResizing = false;
    this.selectedRoomId = null;
    this.currentTool = "rectangle";
    this.isDraggingMarker = false;
    this.previousTool = null;
    this.isDrawingPolygon = false;
    this.polygonPoints = [];
    this.previewPoint = null;
    this.polygonPreviewElement = null;
    this.markers = [];
    this.playerStart = null;
    this.isMarkerEditMode = false;
    this.mapName = null;
    this.layersPanel = new LayersPanel(this);
    this.originalMapName = null;
    this.monsterManager = new MonsterManager(this);
    this.dockingDistance = 5; // Distance in pixels to trigger docking
    this.dockedRooms = new Map(); // Store docked room relationships
    this.isDraggingDocked = false; // Prevent recursive drag handling

    // Initialize managers in correct order
    this.resourceManager = null;  // Initialize to null first
    this.textureManager = null;   // Initialize to null first
    
    // Setup in correct order
    this.setupTitleHandlers();
    this.updateMapTitle();
    this.checkResourceManager(() => {
        console.log('ResourceManager initialized:', !!this.resourceManager);
        this.checkTextureManager(() => {
            console.log('TextureManager initialized:', !!this.textureManager);
            this.setupEventListeners();
        });
    });
    
    this.setupCanvas();
    this.calculateLayersListHeight = this.calculateLayersListHeight.bind(this);
    this.setupLayersObserver();
    setTimeout(() => this.calculateLayersListHeight(), 100);
    window.addEventListener("resize", this.calculateLayersListHeight);
}

checkResourceManager(callback) {
    const resourceManagerBtn = document.getElementById('resourceManagerBtn');
    
    // Create a temporary script element to test loading
    const script = document.createElement('script');
    script.src = 'resource-manager.js';
    script.onload = () => {
        // Resource manager loaded successfully
        this.resourceManager = new ResourceManager();
        if (resourceManagerBtn) {
            resourceManagerBtn.style.display = 'flex';
            resourceManagerBtn.innerHTML = `
                <span class="material-icons">palette</span>
                Res.
            `;
            
            // Add click handler
            resourceManagerBtn.addEventListener('click', () => {
                const drawer = this.resourceManager.createResourceManagerUI();
                drawer.show();
            });
        }
        if (callback) callback();
    };
    script.onerror = () => {
        console.warn('Resource manager not available');
        if (resourceManagerBtn) {
            resourceManagerBtn.style.display = 'none';
        }
        if (callback) callback();
    };
    document.head.appendChild(script);
}

checkTextureManager(callback) {
    const script = document.createElement('script');
    script.src = 'texture-manager.js';
    script.onload = () => {
        console.log('TextureManager script loaded');
        if (this.resourceManager) {
            this.textureManager = new TextureManager(this);
            console.log('TextureManager created with ResourceManager');
        } else {
            console.warn('Creating TextureManager without ResourceManager');
            this.textureManager = new TextureManager(this);
        }
        if (callback) callback();
    };
    script.onerror = () => {
        console.warn('Texture manager not available');
        if (callback) callback();
    };
    document.head.appendChild(script);
}



                snapToGrid(value, gridSize, snapThreshold = 0.25) {
            if (!gridSize) return value;
            
            const gridPosition = Math.round(value / gridSize) * gridSize;
            const offset = value - gridPosition;
            
            // Only snap if within threshold (25% of grid size by default)
            if (Math.abs(offset) < gridSize * snapThreshold) {
                return gridPosition;
            }
            
            return value;
        }

        calculateDockOffset(mainRoom, dockingRoom, position) {
    let newX = dockingRoom.bounds.x;  // Start with current position
    let newY = dockingRoom.bounds.y;

    switch(position) {
        // Right side positions
        case 'right-top':
            newX = mainRoom.bounds.x + mainRoom.bounds.width;
            newY = mainRoom.bounds.y;
            break;
        case 'right-middle':
            newX = mainRoom.bounds.x + mainRoom.bounds.width;
            newY = mainRoom.bounds.y + (mainRoom.bounds.height - dockingRoom.bounds.height) / 2;
            break;
        case 'right-bottom':
            newX = mainRoom.bounds.x + mainRoom.bounds.width;
            newY = mainRoom.bounds.y + mainRoom.bounds.height - dockingRoom.bounds.height;
            break;

        // Left side positions
        case 'left-top':
            newX = mainRoom.bounds.x - dockingRoom.bounds.width;
            newY = mainRoom.bounds.y;
            break;
        case 'left-middle':
            newX = mainRoom.bounds.x - dockingRoom.bounds.width;
            newY = mainRoom.bounds.y + (mainRoom.bounds.height - dockingRoom.bounds.height) / 2;
            break;
        case 'left-bottom':
            newX = mainRoom.bounds.x - dockingRoom.bounds.width;
            newY = mainRoom.bounds.y + mainRoom.bounds.height - dockingRoom.bounds.height;
            break;

        // Top side positions
        case 'top-left':
            newX = mainRoom.bounds.x;
            newY = mainRoom.bounds.y - dockingRoom.bounds.height;
            break;
        case 'top-center':
            newX = mainRoom.bounds.x + (mainRoom.bounds.width - dockingRoom.bounds.width) / 2;
            newY = mainRoom.bounds.y - dockingRoom.bounds.height;
            break;
        case 'top-right':
            newX = mainRoom.bounds.x + mainRoom.bounds.width - dockingRoom.bounds.width;
            newY = mainRoom.bounds.y - dockingRoom.bounds.height;
            break;

        // Bottom side positions
        case 'bottom-left':
            newX = mainRoom.bounds.x;
            newY = mainRoom.bounds.y + mainRoom.bounds.height;
            break;
        case 'bottom-center':
            newX = mainRoom.bounds.x + (mainRoom.bounds.width - dockingRoom.bounds.width) / 2;
            newY = mainRoom.bounds.y + mainRoom.bounds.height;
            break;
        case 'bottom-right':
            newX = mainRoom.bounds.x + mainRoom.bounds.width - dockingRoom.bounds.width;
            newY = mainRoom.bounds.y + mainRoom.bounds.height;
            break;
    }

    // Calculate the offset from current position
    return {
        x: newX - dockingRoom.bounds.x,
        y: newY - dockingRoom.bounds.y
    };
}

dockRooms(mainRoom, dockingRoom, position) {
    if (!mainRoom || !dockingRoom) return;

    // Calculate where dockingRoom should move to
    const offset = this.calculateDockOffset(mainRoom, dockingRoom, position);
    
    // Move the docking room
    dockingRoom.bounds.x += offset.x;
    dockingRoom.bounds.y += offset.y;
    
    // Store docking relationship
    if (!this.dockedRooms.has(dockingRoom.id)) {
        this.dockedRooms.set(dockingRoom.id, []);
    }
    
    this.dockedRooms.get(dockingRoom.id).push({
        room: mainRoom,
        position: position,
        offset: { ...offset }
    });

    // Update visual elements
    dockingRoom.updateElement();
    dockingRoom.element.classList.add('docked');
    mainRoom.element.classList.add('docked');

    console.log('Docking complete:', {
        mainRoomId: mainRoom.id,
        dockingRoomId: dockingRoom.id,
        position,
        newPosition: {
            x: dockingRoom.bounds.x,
            y: dockingRoom.bounds.y
        },
        offset
    });
}


undockRoom(room) {
    if (this.dockedRooms.has(room.id)) {
        // Get all docking relationships for this room
        const dockings = this.dockedRooms.get(room.id);
        
        dockings.forEach(({ room: targetRoom, offset }) => {
            // Remove visual indicators
            targetRoom.element.classList.remove('docked');
            
            // Remove any stored relationships where this room is the target
            this.dockedRooms.forEach((relationships, key) => {
                if (relationships.some(rel => rel.room.id === room.id)) {
                    this.dockedRooms.delete(key);
                }
            });
        });

        // Remove visual indicator from source room
        room.element.classList.remove('docked');
        
        // Remove all docking relationships for this room
        this.dockedRooms.delete(room.id);

        console.log('Room undocked:', {
            roomId: room.id,
            previousDockings: dockings
        });
    }
}


        showLockedMessage() {
    const toast = document.createElement('sl-dialog');
    toast.label = 'Layer Locked';
    toast.innerHTML = `
        <div style="display: flex; align-items: center; gap: 8px;">
            <span class="material-icons" style="color: #f44336;">lock</span>
            <span>This layer is locked. Unlock it to make changes.</span>
        </div>
        <div slot="footer">
            <sl-button variant="primary" class="ok-btn">OK</sl-button>
        </div>
    `;
    document.body.appendChild(toast);
    
    const okBtn = toast.querySelector('.ok-btn');
    okBtn.addEventListener('click', () => toast.hide());
    toast.addEventListener('sl-after-hide', () => toast.remove());
    
    toast.show();
}

parseMapFilename(filename) {
    // Remove file extension
    const nameWithoutExt = filename.replace(/\.[^/.]+$/, "");
    
    // Try to find grid dimensions (like 32x20)
    const gridMatch = nameWithoutExt.match(/(\d+)x(\d+)/i);
    
    // Try to find a map name
    let mapName = nameWithoutExt;
    
    // Remove any leading numbers and separators
    mapName = mapName.replace(/^[\d-_\s]+/, '');
    
    // Remove the grid dimensions if present
    mapName = mapName.replace(/\s*\d+x\d+\s*$/, '');
    
    // Clean up any remaining underscores or extra spaces
    mapName = mapName.replace(/_/g, ' ').trim();

    const result = {
        success: true,
        gridDimensions: gridMatch ? {
            width: parseInt(gridMatch[1]),
            height: parseInt(gridMatch[2])
        } : null,
        mapName: mapName || null
    };

    // Update the title if we have a valid map name
    if (result.success && result.mapName) {
        this.mapName = result.mapName;
        this.updateMapTitle();
    }

    return result;
}

// Add these new methods
updateMapTitle() {
    const titleElement = document.getElementById('mapTitleText');
    if (titleElement) {
        if (this.mapName) {
            titleElement.textContent = this.mapName;
        } else {
            titleElement.textContent = 'Untitled Map';
        }
    }
}

setupTitleHandlers() {
    const titleContainer = document.getElementById('mapTitle');
    if (titleContainer) {
        titleContainer.addEventListener('click', async () => {
            const result = await this.showMapNameDialog();
            if (result) {
                this.updateMapTitle();
            }
        });
    }
}

        async showMapNameDialog() {
  const dialog = document.createElement('sl-dialog');
  dialog.label = 'New Map';
  dialog.innerHTML = `
    <div style="display: flex; flex-direction: column; gap: 16px;">
      <sl-input
        id="mapNameInput"
        label="Map Name"
        placeholder="Enter map name"
        help-text="This will be used in the saved file name"
        required
      ></sl-input>
    </div>
    <div slot="footer">
      <sl-button variant="neutral" class="cancel-btn">Cancel</sl-button>
      <sl-button variant="primary" class="save-btn">Create</sl-button>
    </div>
  `;

  document.body.appendChild(dialog);

  return new Promise((resolve) => {
    const mapNameInput = dialog.querySelector('#mapNameInput');
    const saveBtn = dialog.querySelector('.save-btn');
    const cancelBtn = dialog.querySelector('.cancel-btn');

    const handleSave = () => {
      const mapName = mapNameInput.value.trim();
      if (mapName) {
        this.mapName = mapName; // Store map name in class
        dialog.hide();
        resolve(true);
      } else {
        mapNameInput.reportValidity();
      }
    };

    const handleCancel = () => {
      dialog.hide();
      resolve(false);
    };

    saveBtn.addEventListener('click', handleSave);
    cancelBtn.addEventListener('click', handleCancel);
    mapNameInput.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') handleSave();
      if (e.key === 'Escape') handleCancel();
    });

    dialog.addEventListener('sl-after-hide', () => {
      dialog.remove();
    });

    dialog.show();
    setTimeout(() => mapNameInput.focus(), 100);
  });
}

async saveMap() {
    // Show saving notification
    const toast = document.createElement("div");
    toast.style.position = "fixed";
    toast.style.bottom = "20px";
    toast.style.right = "20px";
    toast.style.zIndex = "1000";
    toast.style.backgroundColor = "#333";
    toast.style.color = "white";
    toast.style.padding = "10px 20px";
    toast.style.borderRadius = "4px";
    toast.style.display = "flex";
    toast.style.alignItems = "center";
    toast.style.gap = "10px";
    toast.innerHTML = `
        <span class="material-icons">save</span>
        <span>Saving map...</span>
    `;
    document.body.appendChild(toast);

    try {
        console.log("Starting map save...");
        // Create the save data structure
        const saveData = {
            version: "1.2", // Bump version for texture support
            timestamp: new Date().toISOString(),
            mapImage: null,
            gridSettings: {
                cellSize: this.cellSize,
                width: this.gridDimensions?.width,
                height: this.gridDimensions?.height
            },
            rooms: this.rooms.map((room) => {
                console.log("Saving room:", {
                    id: room.id,
                    shape: room.shape,
                    bounds: room.bounds
                });
                return {
                    id: room.id,
                    name: room.name,
                    shape: room.shape,
                    bounds: { ...room.bounds },
                    points: room.points ? [...room.points] : null,
                    isRaisedBlock: room.isRaisedBlock || false,
        blockHeight: room.blockHeight || 0,
        finalized: room.finalized,
        locked: room.locked,
                    thumbnail: room.thumbnail,
                    type: room.type,
                    locked: room.locked
                };
            }),
            textureData: {
        assignments: this.resourceManager?.serializeTextureAssignments(),
        activeResourcePack: this.resourceManager?.activeResourcePack?.name
    },

                // Add player start marker if it exists
    playerStart: this.playerStart ? {
        id: this.playerStart.id,
        type: this.playerStart.type,
        x: this.playerStart.x,
        y: this.playerStart.y,
        data: { ...this.playerStart.data }
    } : null,
            markers: this.markers.map((marker) => {
                console.log("Saving marker:", {
                    type: marker.type,
                    id: marker.id
                });

                // Create a clean copy of marker data
                const markerData = {
                    id: marker.id,
                    type: marker.type,
                    x: marker.x,
                    y: marker.y,
                    data: {}
                };

                // Copy non-circular data
                if (marker.data) {
                    Object.keys(marker.data).forEach((key) => {
                        // Skip the pairedMarker object reference
                        if (key !== "pairedMarker") {
                            markerData.data[key] = marker.data[key];
                        }
                    });

                    // Handle parent wall reference for doors
                    if (marker.data.parentWall) {
                        markerData.data.parentWallId = marker.data.parentWall.id;
                        delete markerData.data.parentWall;
                    }

                    // Save texture data if present
                    if (marker.data.texture) {
                        markerData.data.textureId = marker.data.texture.id;
                        markerData.data.textureCategory = marker.data.texture.category;
                    }
                }

                // Special handling for different marker types
                if (marker.type === "encounter" && marker.data.monster) {
                    // Keep existing monster data handling
                    markerData.data.monster = {
                        basic: { ...marker.data.monster.basic },
                        stats: {
                            ac: marker.data.monster.stats.ac,
                            hp: { ...marker.data.monster.stats.hp },
                            speed: marker.data.monster.stats.speed
                        },
                        abilities: { ...marker.data.monster.abilities },
                        traits: { ...marker.data.monster.traits },
                        token: {
                            data: marker.data.monster.token.data,
                            url: marker.data.monster.token.url
                        }
                    };
                } else if (marker.type === "teleport" && marker.data.pairedMarker) {
                    markerData.data.pairId = marker.data.pairedMarker.id;
                    markerData.data.isPointA = marker.data.isPointA;
                    markerData.data.hasPair = true;
                }

                return markerData;
            }),
            // Add reference to resource pack if one is loaded
            resourcePack: this.resourceManager?.activeResourcePack?.name || null
        };

        // Convert main map image to base64
        if (this.baseImage) {
            const canvas = document.createElement("canvas");
            canvas.width = this.baseImage.width;
            canvas.height = this.baseImage.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(this.baseImage, 0, 0);
            saveData.mapImage = canvas.toDataURL("image/webp");
        }

        console.log("Map data prepared, creating file...");

        // Create the file
        const blob = new Blob([JSON.stringify(saveData, null, 2)], {
            type: "application/json"
        });

        // Generate filename based on map name and timestamp
        const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
        const mapName = this.mapName || this.originalMapName || "untitled";
        const filename = `${mapName}-${timestamp}.json`;

        // Trigger download
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(a.href);

        console.log("Map save completed");

        // Show success toast
        toast.style.backgroundColor = "#4CAF50";
        toast.innerHTML = `
            <span class="material-icons">check_circle</span>
            <span>Map saved successfully!</span>
        `;
    } catch (error) {
        console.error("Error saving map:", error);
        toast.style.backgroundColor = "#f44336";
        toast.innerHTML = `
            <span class="material-icons">error</span>
            <span>Error saving map!</span>
        `;
    }

    // Remove toast after delay
    setTimeout(() => toast.remove(), 2000);
}

async loadMap(file) {
    const toast = document.createElement("div");
    toast.style.position = "fixed";
    toast.style.bottom = "20px";
    toast.style.right = "20px";
    toast.style.zIndex = "1000";
    toast.style.backgroundColor = "#333";
    toast.style.color = "white";
    toast.style.padding = "10px 20px";
    toast.style.borderRadius = "4px";
    toast.style.display = "flex";
    toast.style.alignItems = "center";
    toast.style.gap = "10px";
    toast.innerHTML = `
        <span class="material-icons">hourglass_top</span>
        <span>Loading map...</span>
    `;
    document.body.appendChild(toast);

    try {
        console.log("Starting map load...");
        const text = await file.text();
        const saveData = JSON.parse(text);

        // Version check
        console.log("Loading map version:", saveData.version);
        
        // Clear existing rooms and markers first
        this.rooms.forEach(room => {
            room.element?.remove();
        });
        this.rooms = [];

        this.markers.forEach(marker => {
            marker.element?.remove();
        });
        this.markers = [];

        if (this.playerStart?.element) {
            this.playerStart.element.remove();
            this.playerStart = null;
        }

        // Load resource pack if specified
    //     if (saveData.textureData?.activeResourcePack && this.resourceManager) {
    //     console.log("Loading associated resource pack:", saveData.textureData.activeResourcePack);
    //     await this.resourceManager.loadResourcePackByName(saveData.textureData.activeResourcePack);
    // }

    // Restore texture assignments
    if (saveData.textureData?.assignments && this.resourceManager) {
        this.resourceManager.deserializeTextureAssignments(saveData.textureData.assignments);
    }

        // Load map image first and wait for it to complete
        if (saveData.mapImage) {
            await new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    this.baseImage = img;
                    this.naturalWidth = img.naturalWidth;
                    this.naturalHeight = img.naturalHeight;
                    resolve();
                };
                img.onerror = reject;
                img.src = saveData.mapImage;
            });
        }

        // Restore grid settings
        // this.cellSize = saveData.gridSettings.cellSize;
        // this.gridDimensions = saveData.gridSettings.width && saveData.gridSettings.height
        //     ? {
        //         width: saveData.gridSettings.width,
        //         height: saveData.gridSettings.height
        //     }
        //     : null;

        // console.log("Grid settings restored:", this.gridDimensions);

        // Initialize default grid settings
const defaultGridSettings = {
    cellSize: 50,  // default cell size
    width: null,
    height: null
};

// Try to get grid settings from save data, fall back to defaults
const gridSettings = saveData.gridSettings || defaultGridSettings;

// Apply grid settings with fallback values
this.cellSize = gridSettings.cellSize || defaultGridSettings.cellSize;
this.gridDimensions = gridSettings.width && gridSettings.height
    ? {
        width: gridSettings.width,
        height: gridSettings.height
    }
    : null;

console.log("Grid settings restored:", {
    cellSize: this.cellSize,
    dimensions: this.gridDimensions
});

        // Restore rooms
        for (const roomData of saveData.rooms) {
            console.log("Creating room:", {
                id: roomData.id,
                shape: roomData.shape,
                type: roomData.type,
                bounds: roomData.bounds
            });

            const room = Room.createFromSaved(roomData, this);
    // Restore raised block properties
    room.isRaisedBlock = roomData.isRaisedBlock || false;
    room.blockHeight = roomData.blockHeight || 0;
    
    if (roomData.locked) {
        room.locked = true;
    }
            this.rooms.push(room);
            document.querySelector('.canvas-container').appendChild(room.element);
        }

        // Restore markers
        console.log("Starting marker restoration...");
        for (const markerData of saveData.markers) {
            console.log("Loading marker:", {
                type: markerData.type,
                data: markerData.data
            });

            if (saveData.playerStart) {
        console.log("Restoring player start marker:", saveData.playerStart);
        this.playerStart = this.addMarker(
            "player-start",
            saveData.playerStart.x,
            saveData.playerStart.y,
            saveData.playerStart.data || {}
        );
    }

            // Handle texture restoration
            if (markerData.data.textureId && this.resourceManager) {
                const texture = this.resourceManager.resources.textures[markerData.data.textureCategory]?.get(markerData.data.textureId);
                if (texture) {
                    markerData.data.texture = texture;
                }
            }

            // Handle parent wall restoration for doors
            if (markerData.data.parentWallId) {
                markerData.data.parentWall = this.rooms.find(r => r.id === markerData.data.parentWallId);
            }

            const marker = this.addMarker(
                markerData.type,
                markerData.x,
                markerData.y,
                markerData.data
            );

            if (marker.type === "encounter" && marker.data.monster) {
                this.updateMarkerAppearance(marker);
            }
        }

        // Restore teleport connections
        console.log("Restoring teleport connections...");
        const teleportMarkers = this.markers.filter(m => m.type === "teleport");
        for (const marker of teleportMarkers) {
            if (marker.data.pairId) {
                const pair = teleportMarkers.find(
                    m => m.data.pairId === marker.data.pairId && m !== marker
                );
                if (pair) {
                    console.log("Connecting teleport pair:", {
                        markerA: marker.id,
                        markerB: pair.id
                    });

                    marker.data.pairedMarker = pair;
                    pair.data.pairedMarker = marker;
                    marker.data.hasPair = true;
                    pair.data.hasPair = true;

                    if (marker.data.isPointA) {
                        if (marker.connection) {
                            marker.connection.remove();
                        }
                        marker.connection = this.createTeleportConnection(marker, pair);
                        this.updateTeleportConnection(marker, pair);
                    }
                }
            }
        }

        // Update all marker positions
        this.markers.forEach(marker => {
            this.updateMarkerPosition(marker);
        });

        // Update display
        this.centerMap();
        this.render();
        this.layersPanel.updateLayersList();

        console.log("Map load completed");

        // Success notification
        toast.style.backgroundColor = "#4CAF50";
        toast.innerHTML = `
            <span class="material-icons">check_circle</span>
            <span>Map loaded successfully!</span>
        `;
    } catch (error) {
        console.error("Error loading map:", error);
        toast.style.backgroundColor = "#f44336";
        toast.innerHTML = `
            <span class="material-icons">error</span>
            <span>Error loading map!</span>
        `;
    }

    // Remove toast after delay
    setTimeout(() => {
    toast.remove();
    
    // Temporarily zoom out and back in to force marker updates
    const originalScale = this.scale;
    
    // Zoom out
    this.scale *= 0.9;
    this.rooms.forEach(room => room.updateElement());
    this.updateMarkerPositions();
    
    // Wait a frame then zoom back in
    requestAnimationFrame(() => {
        this.scale = originalScale;
        this.rooms.forEach(room => room.updateElement());
        this.updateMarkerPositions();
        this.render();
    });
}, 2000);

    this.centerMap();
}

        clearMap() {
          // Clear all rooms
          this.rooms.forEach((room) => {
            room.element?.remove();
          });
          this.rooms = [];

          // Clear all markers
          this.markers.forEach((marker) => {
            marker.element?.remove();
          });
          this.markers = [];

          // Clear player start
          if (this.playerStart?.element) {
            this.playerStart.element.remove();
            this.playerStart = null;
          }

          // Clear base image
          this.baseImage = null;

          // Reset view settings
          this.scale = 1;
          this.offset = { x: 0, y: 0 };

          // Update display
          this.render();
          this.layersPanel.updateLayersList();
        }

        calculateLayersListHeight() {
          const sidebar = document.querySelector(".sidebar");
          const sidebarContent = document.querySelector(".sidebar-content");
          const layersPanel = document.querySelector(".layers-panel");
          const mainHeader = document.querySelector(".header");

          if (sidebar && sidebarContent && layersPanel && mainHeader) {
            // Get toolbar sections height
            const toolSections = document.querySelectorAll(".tool-section");
            let toolbarHeight = 0;
            toolSections.forEach((section) => {
              if (!section.closest(".layers-panel")) {
                // Only count non-layers-panel sections
                toolbarHeight += section.offsetHeight;
              }
            });

            // Calculate available height
            const totalHeight = window.innerHeight;
            const headerHeight = mainHeader.offsetHeight;
            const availableHeight =
              totalHeight - headerHeight - toolbarHeight - 40; // 40px for padding


            // Set the panel height
            layersPanel.style.height = `${availableHeight}px`;
          }
        }

        setupLayersObserver() {
          const layersList = document.querySelector("#layersList");
          if (layersList) {
            const observer = new MutationObserver(
              this.calculateLayersListHeight
            );
            observer.observe(layersList, {
              childList: true,
              subtree: true
            });
          }
        }

        setupCanvas() {
          const updateCanvasSize = () => {
            const container = this.canvas.parentElement;
            this.canvas.width = container.clientWidth;
            this.canvas.height = container.clientHeight;
            this.render();
          };

          window.addEventListener("resize", updateCanvasSize);
          updateCanvasSize();
        }

        setupShapeSelector() {
          const splitButton = document.querySelector("sl-split-button");
          const menu = splitButton.querySelector("sl-menu");

          // Update the main button when a shape is selected
          const updateMainButton = (shape) => {
            const iconName = {
              rectangle: "square",
              circle: "circle",
              polygon: "pentagon"
            }[shape];

            const icon = splitButton.querySelector('sl-icon[slot="prefix"]');
            const label = splitButton.querySelector(".shape-label");

            icon.name = iconName;
            label.textContent = shape.charAt(0).toUpperCase() + shape.slice(1);
          };

          // Handle menu selection
          menu.addEventListener("sl-select", (event) => {
            const shape = event.detail.item.value;
            this.setShape(shape);
            updateMainButton(shape);
          });

          // Handle main button click
          splitButton.addEventListener("click", () => {
            // Start room creation with current shape
            if (this.currentShape === "rectangle") {
              this.startRoomCreation();
            } else if (this.currentShape === "circle") {
              this.startCircleRoom();
            } else if (this.currentShape === "polygon") {
              this.startPolygonRoom();
            }
          });
        }

        setShape(shape) {
          this.currentShape = shape;
          // Update any visual indicators or state
        //   console.log(`Shape set to: ${shape}`);
        }

        setupEventListeners() {
          // File handling
          const openMapBtn = document.getElementById("openMapBtn");

          if (openMapBtn) {
            openMapBtn.addEventListener("click", () => {
              const dialog = document.createElement("sl-dialog");
              dialog.label = "Open Map";

              dialog.innerHTML = `
            <div style="display: flex; flex-direction: column; gap: 16px;">
                <sl-button size="large" class="new-map-btn" style="justify-content: flex-start;">
                    <span slot="prefix" class="material-icons">add_circle</span>
                    New Map
                    <div style="font-size: 0.8em; color: #666; margin-top: 4px;">
                        Start fresh with a new map (clears everything)
                    </div>
                </sl-button>

                <sl-button size="large" class="change-picture-btn" style="justify-content: flex-start;">
                    <span slot="prefix" class="material-icons">image</span>
                    Change Background
                    <div style="font-size: 0.8em; color: #666; margin-top: 4px;">
                        Change map background while keeping rooms and markers
                    </div>
                </sl-button>

                <sl-button size="large" class="load-project-btn" style="justify-content: flex-start;">
                    <span slot="prefix" class="material-icons">folder_open</span>
                    Load Project
                    <div style="font-size: 0.8em; color: #666; margin-top: 4px;">
                        Open a previously saved map project
                    </div>
                </sl-button>
            </div>
        `;

              // Create hidden file inputs
              const pictureInput = document.createElement("input");
              pictureInput.type = "file";
              pictureInput.accept = "image/*";
              pictureInput.style.display = "none";

              const jsonInput = document.createElement("input");
              jsonInput.type = "file";
              jsonInput.accept = ".json";
              jsonInput.style.display = "none";

              document.body.appendChild(pictureInput);
              document.body.appendChild(jsonInput);

              // Handle picture file selection

    pictureInput.addEventListener('change', async e => {
  const file = e.target.files[0];
  if (file) {
    // Parse filename first
    const parseResult = this.parseMapFilename(file.name);


    // If we couldn't get a map name or user wants to change it, show dialog
    let mapName = parseResult.mapName;

    
    if (!mapName || !parseResult.success) {
      // Show name dialog as fallback
      const nameConfirmed = await this.showMapNameDialog();
      if (!nameConfirmed) {
        return; // User cancelled
      }
    } else {
      // Found a name, but let's confirm with the user
      const dialog = document.createElement('sl-dialog');
      dialog.label = 'Map Name';
      dialog.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 16px;">
          <sl-input
            id="mapNameInput"
            label="Map Name"
            value="${mapName}"
            help-text="Parsed from filename. You can modify if needed."
          ></sl-input>
          ${parseResult.gridDimensions ? `
            <div style="color: #666;">
              Grid Size: ${parseResult.gridDimensions.width}x${parseResult.gridDimensions.height}
            </div>
          ` : ''}
        </div>
        <div slot="footer">
          <sl-button variant="neutral" class="cancel-btn">Cancel</sl-button>
          <sl-button variant="primary" class="save-btn">Continue</sl-button>
        </div>
      `;

      document.body.appendChild(dialog);

      // Return a promise that resolves when the dialog is handled
      await new Promise((resolve) => {
        const mapNameInput = dialog.querySelector('#mapNameInput');
        const saveBtn = dialog.querySelector('.save-btn');
        const cancelBtn = dialog.querySelector('.cancel-btn');

        saveBtn.addEventListener('click', () => {
          mapName = mapNameInput.value.trim();
          this.mapName = mapName;
          this.originalMapName = mapName;
          dialog.hide();
          resolve(true);
        });

        cancelBtn.addEventListener('click', () => {
          dialog.hide();
          resolve(false);
        });

        dialog.addEventListener('sl-after-hide', () => {
          dialog.remove();
        });

        dialog.show();
      });
    }

    // Set grid dimensions if found
    if (parseResult.gridDimensions) {
      this.gridDimensions = parseResult.gridDimensions;
    }
                  // Show loading notification
                  const toast = document.createElement("div");
                  toast.style.position = "fixed";
                  toast.style.bottom = "20px";
                  toast.style.right = "20px";
                  toast.style.zIndex = "1000";
                  toast.style.backgroundColor = "#333";
                  toast.style.color = "white";
                  toast.style.padding = "10px 20px";
                  toast.style.borderRadius = "4px";
                  toast.style.display = "flex";
                  toast.style.alignItems = "center";
                  toast.style.gap = "10px";
                  toast.innerHTML = `
                    <span class="material-icons">hourglass_top</span>
                    <span>Loading ${file.name}...</span>
                `;
                  document.body.appendChild(toast);

                  try {
                    // Parse grid dimensions from filename
                    const mapDimensions = parseMapDimensions(file.name);
                    if (mapDimensions) {
                      this.gridDimensions = mapDimensions;
                    }

                    const reader = new FileReader();
                    await new Promise((resolve, reject) => {
                      reader.onload = (event) => {
                        const img = new Image();
                        img.onload = () => {
                          this.baseImage = img;

                          // Calculate DPI if possible
                          if (this.gridDimensions) {
                            const cellWidth =
                              img.width / this.gridDimensions.width;
                            const cellHeight =
                              img.height / this.gridDimensions.height;
                            this.cellSize = Math.min(cellWidth, cellHeight);
                            // console.log(
                            //   `Calculated cell size: ${this.cellSize}px`
                            // );
                          }

                          // Store the natural dimensions
                          this.naturalWidth = img.naturalWidth;
                          this.naturalHeight = img.naturalHeight;

                          this.centerMap();
                          this.render();
                          resolve();
                        };
                        img.onerror = reject;
                        img.src = event.target.result;
                      };
                      reader.onerror = reject;
                      reader.readAsDataURL(file);
                    });

                    // Success notification
                    toast.style.backgroundColor = "#4CAF50";
                    toast.innerHTML = `
                        <span class="material-icons">check_circle</span>
                        <span>Map loaded successfully!</span>
                    `;
                    setTimeout(() => toast.remove(), 2000);
                  } catch (error) {
                    console.error("Error loading map:", error);
                    // Error notification
                    toast.style.backgroundColor = "#f44336";
                    toast.innerHTML = `
                        <span class="material-icons">error</span>
                        <span>Error loading map!</span>
                    `;
                    setTimeout(() => toast.remove(), 2000);
                  }
                  dialog.hide();
                }
              });

              // Handle JSON file selection
              jsonInput.addEventListener("change", async (e) => {
                const file = e.target.files[0];
                if (file) {
                  await this.loadMap(file);
                  dialog.hide();
                }
              });

              // Add button click handlers
              dialog
                .querySelector(".new-map-btn")
                .addEventListener("click", () => {
                  pictureInput.click();
                  this.clearMap(); // Clear everything before loading new picture
                  dialog.hide();
                });

              // Change Picture button handler
              dialog
                .querySelector(".change-picture-btn")
                .addEventListener("click", () => {
                  pictureInput.click();
                  dialog.hide();
                });

              // Load Project button handler
              dialog
                .querySelector(".load-project-btn")
                .addEventListener("click", () => {
                  jsonInput.click();
                  dialog.hide();
                });

              // Clean up on close
              dialog.addEventListener("sl-after-hide", () => {
                dialog.remove();
                pictureInput.remove();
                jsonInput.remove();
              });

              // Show the dialog
              document.body.appendChild(dialog);
              dialog.show();
            });
          }

          const saveProjectBtn = document.getElementById("saveProjectBtn");
          if (saveProjectBtn) {
            saveProjectBtn.addEventListener("click", () => this.saveMap());
          }

          // Create 3D view button
          const create3dBtn = document.getElementById("create3d");
          if (create3dBtn) {
            create3dBtn.addEventListener("click", () => this.show3DView());
          }

          const toolButtons = document.querySelectorAll(".tool-button");
          toolButtons.forEach((button) => {
            button.addEventListener("click", () => {
              switch (button.id) {
                case "selectTool":
                  this.setTool("rectangle");
                  break;
                case "circleTool":
                  this.setTool("circle");
                  break;
                case "wallTool":
                  this.setTool("wall");
                  break;
                case "panTool":
                  this.setTool("pan");
                  break;
                case "centerMap":
                  this.centerMap();
                  break;
                case "zoomFit":
                  this.zoomToFit();
                  break;
              }
            });
          });

          this.setupMiddleClickHandlers();

          // Canvas events
          const wrapper = document.getElementById("canvasWrapper");
          if (wrapper) {
            wrapper.addEventListener(
              "mousedown",
              this.handleMouseDown.bind(this)
            );
            wrapper.addEventListener(
              "mousemove",
              this.handleMouseMove.bind(this)
            );
            wrapper.addEventListener("mouseup", this.handleMouseUp.bind(this));
            wrapper.addEventListener("wheel", this.handleWheel.bind(this));
          }

          document.getElementById("wallTool")?.addEventListener("click", () => {
            this.setTool("wall");
          });

          // First, get the marker tools container
          const markerToolsContainer = document.querySelector(".marker-tools");
          if (
            markerToolsContainer &&
            !document.getElementById("editMarkerTool")
          ) {
            const editMarkerBtn = document.createElement("div");
            editMarkerBtn.className = "tool-button";
            editMarkerBtn.id = "editMarkerTool";
            editMarkerBtn.setAttribute("data-tooltip", "Edit Markers [M]");
            editMarkerBtn.innerHTML = `<span class="material-icons">edit_location</span>`;
            markerToolsContainer.appendChild(editMarkerBtn);

            // Add edit marker button click handler
            editMarkerBtn.addEventListener("click", () => {
              this.toggleMarkerEditMode();
            });
          }

          // Add keyboard shortcut for marker edit mode
          document.addEventListener("keydown", (e) => {
            if (
              e.key.toLowerCase() === "m" &&
              !e.repeat &&
              e.target.tagName !== "INPUT"
            ) {
              this.toggleMarkerEditMode();
            }
          });

          // Marker tool type mapping
          const markerTools = {
  playerStartTool: "player-start",
  encounterTool: "encounter",
  treasureTool: "treasure", 
  trapTool: "trap",
  teleportTool: "teleport",
  doorTool: "door" 
};

Object.entries(markerTools).forEach(([toolId, markerType]) => {
  document.getElementById(toolId)?.addEventListener("click", () => {
    this.setTool(`marker-${markerType}`);
  });
});

          // Add to your canvas click handler for marker placement
          document
            .getElementById("canvasWrapper")
            .addEventListener("click", (e) => {
              if (this.currentTool?.startsWith("marker-")) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - this.offset.x) / this.scale;
                const y = (e.clientY - rect.top - this.offset.y) / this.scale;
                const markerType = this.currentTool.replace("marker-", "");
                this.addMarker(markerType, x, y);
              }
            });

          window.addEventListener("resize", () => this.handleResize());
        }

        setTool(tool) {
          if (this.currentTool === "wall") {
            this.cleanupWallTool();
          }
          this.currentTool = tool;

          // Update UI
          const toolButtons = document.querySelectorAll(".tool-button");
          toolButtons.forEach((button) => {
            button.classList.remove("active");
            if (
              (tool === "rectangle" && button.id === "selectTool") ||
              (tool === "circle" && button.id === "circleTool") ||
              (tool === "wall" && button.id === "wallTool") ||
              (tool === "pan" && button.id === "panTool")
            ) {
              button.classList.add("active");
            }
          });

          if (tool === "wall") {
            this.startWallCreation();
          }

          // Update cursor style
          const wrapper = document.getElementById("canvasWrapper");
          if (tool === "pan") {
            wrapper.style.cursor = "grab";
          } else if (["rectangle", "circle", "wall"].includes(tool)) {
            wrapper.style.cursor = "crosshair";
          } else {
            wrapper.style.cursor = "default";
          }

          // Update room pointer events
          const rooms = document.querySelectorAll(".room-block");
          rooms.forEach((room) => {
            room.style.pointerEvents = tool.startsWith("marker-")
              ? "none"
              : "auto";
            room
              .querySelectorAll(".room-controls, .resize-handle")
              .forEach((element) => {
                element.style.pointerEvents = "auto";
              });
          });
        }

        handleResize() {
          const container = this.canvas.parentElement;
          this.canvas.width = container.clientWidth;
          this.canvas.height = container.clientHeight;
          this.render();
        }

        zoomToFit() {
          if (!this.baseImage) return;

          const container = this.canvas.parentElement;
          const scaleX = container.clientWidth / this.baseImage.width;
          const scaleY = container.clientHeight / this.baseImage.height;
          this.scale = Math.min(scaleX, scaleY, 1);

          this.offset = {
            x: (container.clientWidth - this.baseImage.width * this.scale) / 2,
            y: (container.clientHeight - this.baseImage.height * this.scale) / 2
          };

          this.rooms.forEach((room) => room.updateElement());
          this.render();
        }

        startWallCreation() {
          if (!this.baseImage) {
            alert("Please load a map first");
            return;
          }

          const wrapper = document.getElementById("canvasWrapper");

          // Remove any existing wall click handler
          if (this.wallClickHandler) {
            wrapper.removeEventListener("click", this.wallClickHandler);
          }

          // Create a new click handler
          this.wallClickHandler = (e) => {
            if (this.currentTool === "wall") {
              e.preventDefault();
              e.stopPropagation();
              this.handleWallClick(e);
            }
          };

          // Add the click handler
          wrapper.addEventListener("click", this.wallClickHandler);
        }

        handleWallClick(e) {
          // Similar to handlePolygonClick but creates wall areas
          const wrapper = document.getElementById("canvasWrapper");
          const rect = wrapper.getBoundingClientRect();
          const x = (e.clientX - rect.left - this.offset.x) / this.scale;
          const y = (e.clientY - rect.top - this.offset.y) / this.scale;

          if (!this.isDrawingPolygon) {
            // Start new wall polygon
            this.isDrawingPolygon = true;
            this.polygonPoints = [{ x, y }];

            // Create preview element
            this.polygonPreviewElement = document.createElement("div");
            this.polygonPreviewElement.className =
              "polygon-preview wall-preview";
            wrapper.appendChild(this.polygonPreviewElement);

            this.updatePolygonPreview();
          } else {
            // Check if near starting point to close wall
            const startPoint = this.polygonPoints[0];
            const distance = Math.sqrt(
              Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2)
            );

            if (distance < 20 / this.scale && this.polygonPoints.length > 2) {
              this.finalizeWall();
            } else {
              // Add new point
              this.polygonPoints.push({ x, y });
              this.updatePolygonPreview();
            }
          }
        }

        finalizeWall() {
          if (!this.isDrawingPolygon || this.polygonPoints.length < 3) return;

          // Calculate bounding box
          const xs = this.polygonPoints.map((p) => p.x);
          const ys = this.polygonPoints.map((p) => p.y);
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);

          // Create wall room
          const wall = new Room(
            Date.now(),
            {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY,
              points: this.polygonPoints.map((p) => ({
                x: p.x - minX,
                y: p.y - minY
              }))
            },
            "",
            "polygon",
            "wall" // Set type as wall
          );

        //   console.log("Created wall:", {
        //     id: wall.id,
        //     type: wall.type,
        //     name: wall.name
        //   });

          this.rooms.push(wall);
          const wallElement = wall.createDOMElement(this);
          document.querySelector(".canvas-container").appendChild(wallElement);
          this.layersPanel.updateLayersList();

          // Clean up
          this.isDrawingPolygon = false;
          this.polygonPoints = [];
          if (this.polygonPreviewElement) {
            this.polygonPreviewElement.remove();
            this.polygonPreviewElement = null;
          }
        }

        createDoor(roomOrWall) {
  const door = {
    id: Date.now(),
    parentId: roomOrWall.id,
    width: this.cellSize, // Default 1 grid cell
    height: this.cellSize * 2, // Default door height
    position: {x: 0, y: 0}, // Will be set when placing
    isOpen: false,
    rotation: 0 // 0 or 90 degrees
  };

  // Add visual representation
  const doorElement = document.createElement('div');
  doorElement.className = 'door';
  doorElement.innerHTML = `
    <div class="door-frame"></div>
    <div class="door-panel"></div>
  `;

  // Add to room/wall
  roomOrWall.doors = roomOrWall.doors || [];
  roomOrWall.doors.push(door);

  return door;
}

findNearestWall(x, y) {
  let nearest = null;
  let minDistance = Infinity;
  
  this.rooms.forEach(room => {
    if (room.type === 'wall') {
      const distance = this.getDistanceToWall(x, y, room);
      if (distance < minDistance) {
        minDistance = distance;
        nearest = room;
      }
    }
  });

  return minDistance < this.cellSize ? nearest : null;
}

isNearWall(x, y, wall) {
  const threshold = this.cellSize;
  const dx = x - wall.bounds.x;
  const dy = y - wall.bounds.y;
  return dx >= -threshold && dx <= wall.bounds.width + threshold &&
         dy >= -threshold && dy <= wall.bounds.height + threshold;
}

getDistanceToWall(x, y, wall) {
  const rect = {
    left: wall.bounds.x,
    right: wall.bounds.x + wall.bounds.width,
    top: wall.bounds.y,
    bottom: wall.bounds.y + wall.bounds.height
  };

  const dx = Math.max(rect.left - x, 0, x - rect.right);
  const dy = Math.max(rect.top - y, 0, y - rect.bottom);
  
  return Math.sqrt(dx * dx + dy * dy);
}

snapToWall(x, y, wall) {
  const edges = {
    left: Math.abs(x - wall.bounds.x),
    right: Math.abs(x - (wall.bounds.x + wall.bounds.width)),
    top: Math.abs(y - wall.bounds.y),
    bottom: Math.abs(y - (wall.bounds.y + wall.bounds.height))
  };

  const closestEdge = Object.entries(edges).reduce((a, b) => a[1] < b[1] ? a : b)[0];

  switch(closestEdge) {
    case 'left': return { x: wall.bounds.x, y };
    case 'right': return { x: wall.bounds.x + wall.bounds.width, y };
    case 'top': return { x, y: wall.bounds.y };
    case 'bottom': return { x, y: wall.bounds.y + wall.bounds.height };
  }
}

findNearestStructure(x, y, type = 'both') {
    let nearest = null;
    let minDistance = Infinity;
    
    this.rooms.forEach(room => {
        // Check if we want this type of structure
        if (type === 'both' || type === room.type) {
            const distance = this.getDistanceToStructure(x, y, room);
            if (distance < minDistance) {
                minDistance = distance;
                nearest = room;
            }
        }
    });

    // Return structure if within cell size distance
    return minDistance < this.cellSize ? nearest : null;
}

isNearStructure(x, y, structure) {
    const threshold = this.cellSize;
    const dx = x - structure.bounds.x;
    const dy = y - structure.bounds.y;
    return dx >= -threshold && dx <= structure.bounds.width + threshold &&
           dy >= -threshold && dy <= structure.bounds.height + threshold;
}

getDistanceToStructure(x, y, structure) {
    const rect = {
        left: structure.bounds.x,
        right: structure.bounds.x + structure.bounds.width,
        top: structure.bounds.y,
        bottom: structure.bounds.y + structure.bounds.height
    };

    const dx = Math.max(rect.left - x, 0, x - rect.right);
    const dy = Math.max(rect.top - y, 0, y - rect.bottom);
    
    return Math.sqrt(dx * dx + dy * dy);
}

snapToStructure(x, y, structure) {
    const edges = {
        left: Math.abs(x - structure.bounds.x),
        right: Math.abs(x - (structure.bounds.x + structure.bounds.width)),
        top: Math.abs(y - structure.bounds.y),
        bottom: Math.abs(y - (structure.bounds.y + structure.bounds.height))
    };

    // Find the closest edge
    const closestEdge = Object.entries(edges).reduce((a, b) => a[1] < b[1] ? a : b)[0];
    
    // Calculate snapped position and determine orientation
    const snappedPos = {
        x: x,
        y: y,
        edge: closestEdge,
        rotation: 0 // Add rotation property
    };

    switch(closestEdge) {
        case 'left': 
            snappedPos.x = structure.bounds.x;
            snappedPos.y = y;
            snappedPos.rotation = 90; // Door faces left
            break;
        case 'right': 
            snappedPos.x = structure.bounds.x + structure.bounds.width;
            snappedPos.y = y;
            snappedPos.rotation = -90; // Door faces right
            break;
        case 'top': 
            snappedPos.x = x;
            snappedPos.y = structure.bounds.y;
            snappedPos.rotation = 0; // Door faces up
            break;
        case 'bottom': 
            snappedPos.x = x;
            snappedPos.y = structure.bounds.y + structure.bounds.height;
            snappedPos.rotation = 180; // Door faces down
            break;
    }

    return snappedPos;
}

        startCircleRoom() {
          if (!this.baseImage) {
            alert("Please load a map first");
            return;
          }

          let roomSize;
          if (this.cellSize) {
            // Use one grid cell as the initial size
            roomSize = this.cellSize;
          } else {
            // Fallback to default size
            roomSize = 100;
          }

          const room = new Room(
            Date.now(),
            {
              x: this.canvas.width / 2 - roomSize / 2,
              y: this.canvas.height / 2 - roomSize / 2,
              width: roomSize,
              height: roomSize
            },
            "",
            "circle",
            "wall" // Set type as wall
          );

          this.rooms.push(room);
          const roomElement = room.createDOMElement(this);
          document.querySelector(".canvas-container").appendChild(roomElement);
          this.layersPanel.updateLayersList();
        }

        startRoomCreation() {
          if (!this.baseImage) {
            alert("Please load a map first");
            return;
          }

          let roomSize;
          if (this.cellSize) {
            // Use one grid cell as the initial size
            roomSize = this.cellSize;
            // console.log("Room size:", roomSize);
            // console.log("Cell size:", this.cellSize);
          } else {
            // Fallback to default size
            roomSize = 100;
          }

              // Get mouse position
    const wrapper = document.getElementById("canvasWrapper");
    const rect = wrapper.getBoundingClientRect();
    
    // Snap to grid
    const x = this.snapToGrid(
        (event.clientX - rect.left - this.offset.x) / this.scale,
        this.cellSize
    );
    const y = this.snapToGrid(
        (event.clientY - rect.top - this.offset.y) / this.scale,
        this.cellSize
    );

          // If polygon tool is selected, set up click handling for points
          if (this.currentTool === "polygon") {
            // Start listening for clicks on the canvas wrapper
            const wrapper = document.getElementById("canvasWrapper");
            const clickHandler = (e) => {
              if (this.currentTool === "polygon") {
                this.handlePolygonClick(e);
              }
            };

            wrapper.addEventListener("click", clickHandler);

            // Store the handler so we can remove it later
            this.polygonClickHandler = clickHandler;
            return;
          }

          const room = new Room(
            Date.now(),
            {
              x: this.canvas.width / 2 - roomSize / 2,
              y: this.canvas.height / 2 - roomSize / 2,
              width: roomSize,
              height: roomSize
            },
            "",
            this.currentTool,
            "wall" // Set type as wall
          );

          // Add room to collection
          this.rooms.push(room);

          // Create and add the room element
          const roomElement = room.createDOMElement(this);
          document.querySelector(".canvas-container").appendChild(roomElement);

          // Immediately set room as editable
          room.updateEditState(true);

          // Update layers panel
          this.layersPanel.updateLayersList();

          // Set this as the selected room
          this.selectedRoomId = room.id;
        }

        handlePolygonClick(e) {
          const wrapper = document.getElementById("canvasWrapper");
          const rect = wrapper.getBoundingClientRect();
          const x = (e.clientX - rect.left - this.offset.x) / this.scale;
          const y = (e.clientY - rect.top - this.offset.y) / this.scale;

          if (!this.isDrawingPolygon) {
            // Start new polygon
            this.isDrawingPolygon = true;
            this.polygonPoints = [{ x, y }];

            // Create preview element
            this.polygonPreviewElement = document.createElement("div");
            this.polygonPreviewElement.className = "polygon-preview";
            wrapper.appendChild(this.polygonPreviewElement);

            this.updatePolygonPreview();
          } else {
            // Check if near starting point to close polygon
            const startPoint = this.polygonPoints[0];
            const distance = Math.sqrt(
              Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2)
            );

            if (distance < 20 / this.scale && this.polygonPoints.length > 2) {
              this.finalizePolygon();
              // Remove click handler when polygon is complete
              if (this.polygonClickHandler) {
                wrapper.removeEventListener("click", this.polygonClickHandler);
                this.polygonClickHandler = null;
              }
            } else {
              // Add new point
              this.polygonPoints.push({ x, y });
              this.updatePolygonPreview();
            }
          }
        }

        startPolygonRoom(e) {
          if (!this.baseImage) {
            alert("Please load a map first");
            return;
          }

          const wrapper = document.getElementById("canvasWrapper");
          const rect = wrapper.getBoundingClientRect();
          const x = (e.clientX - rect.left - this.offset.x) / this.scale;
          const y = (e.clientY - rect.top - this.offset.y) / this.scale;

          if (!this.isDrawingPolygon) {
            // Start new polygon
            this.isDrawingPolygon = true;
            this.polygonPoints = [{ x, y }];

            // Create preview element
            this.polygonPreviewElement = document.createElement("div");
            this.polygonPreviewElement.className = "polygon-preview";
            wrapper.appendChild(this.polygonPreviewElement);

            // Add preview line
            const previewLine = document.createElement("div");
            previewLine.className = "preview-line";
            this.polygonPreviewElement.appendChild(previewLine);

            this.updatePolygonPreview();
          } else {
            // Check if near starting point to close polygon
            const startPoint = this.polygonPoints[0];
            const distance = Math.sqrt(
              Math.pow(x - startPoint.x, 2) + Math.pow(y - startPoint.y, 2)
            );

            if (distance < 20 / this.scale && this.polygonPoints.length > 2) {
              this.finalizePolygon();
            } else {
              // Add new point
              this.polygonPoints.push({ x, y });
              this.updatePolygonPreview();
            }
          }
        }

        updatePolygonPreview() {
          if (!this.polygonPreviewElement) return;

          // Create SVG path string
          let pathData = "";
          this.polygonPoints.forEach((point, index) => {
            const x = point.x * this.scale + this.offset.x;
            const y = point.y * this.scale + this.offset.y;
            pathData += index === 0 ? `M ${x},${y} ` : `L ${x},${y} `;
          });

          // Add preview line to cursor if we have a preview point
          if (this.previewPoint && this.polygonPoints.length > 0) {
            const lastPoint = this.polygonPoints[this.polygonPoints.length - 1];
            const x = this.previewPoint.x * this.scale + this.offset.x;
            const y = this.previewPoint.y * this.scale + this.offset.y;
            pathData += `L ${x},${y}`;
          }

          // Update preview element
          this.polygonPreviewElement.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
    `;

          this.polygonPreviewElement.innerHTML = `
        <svg style="width: 100%; height: 100%;">
            <path d="${pathData}" 
                  stroke="white" 
                  stroke-width="2" 
                  fill="none" 
                  stroke-dasharray="4 4"/>
        </svg>
    `;

          // Add point markers
          this.polygonPoints.forEach((point, index) => {
            const marker = document.createElement("div");
            marker.className = "polygon-point";
            marker.style.cssText = `
            position: absolute;
            width: 8px;
            height: 8px;
            background: white;
            border: 1px solid #333;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            left: ${point.x * this.scale + this.offset.x}px;
            top: ${point.y * this.scale + this.offset.y}px;
            ${index === 0 ? "background: #4CAF50;" : ""}
        `;
            this.polygonPreviewElement.appendChild(marker);
          });
        }

        finalizePolygon() {
          if (!this.isDrawingPolygon || this.polygonPoints.length < 3) return;

          // Calculate bounding box
          const xs = this.polygonPoints.map((p) => p.x);
          const ys = this.polygonPoints.map((p) => p.y);
          const minX = Math.min(...xs);
          const maxX = Math.max(...xs);
          const minY = Math.min(...ys);
          const maxY = Math.max(...ys);

          // Create room with polygon points
          const room = new Room(
            Date.now(),
            {
              x: minX,
              y: minY,
              width: maxX - minX,
              height: maxY - minY,
              points: this.polygonPoints.map((p) => ({
                x: p.x - minX,
                y: p.y - minY
              }))
            },
            "",
            "polygon",
            "wall" // Set type as wall
          );

          this.rooms.push(room);
          const roomElement = room.createDOMElement(this);
          document.querySelector(".canvas-container").appendChild(roomElement);
          this.layersPanel.updateLayersList();

          // Clean up
          this.isDrawingPolygon = false;
          this.polygonPoints = [];
          if (this.polygonPreviewElement) {
            this.polygonPreviewElement.remove();
            this.polygonPreviewElement = null;
          }
        }

        cancelPolygonDrawing() {
          this.isDrawingPolygon = false;
          this.polygonPoints = [];
          if (this.polygonPreviewElement) {
            this.polygonPreviewElement.remove();
            this.polygonPreviewElement = null;
          }
        }

        cleanupPolygonTool() {
          if (this.polygonClickHandler) {
            const wrapper = document.getElementById("canvasWrapper");
            wrapper.removeEventListener("click", this.polygonClickHandler);
            this.polygonClickHandler = null;
          }
          this.isDrawingPolygon = false;
          this.polygonPoints = [];
          if (this.polygonPreviewElement) {
            this.polygonPreviewElement.remove();
            this.polygonPreviewElement = null;
          }
        }

//         startDragging(room, e) {
//             if (room.locked) {
//         this.showLockedMessage();
//         return;
//     }
//     if (!["rectangle", "circle", "poly"].includes(this.currentTool)) return;

//     const startX = e.clientX;
//     const startY = e.clientY;
//     const startBounds = { ...room.bounds };

//     const moveHandler = (e) => {
//         const dx = (e.clientX - startX) / this.scale;
//         const dy = (e.clientY - startY) / this.scale;

//         // Snap new position to grid
//         const newX = this.snapToGrid(startBounds.x + dx, this.cellSize);
//         const newY = this.snapToGrid(startBounds.y + dy, this.cellSize);

//         room.bounds.x = newX;
//         room.bounds.y = newY;

//         room.updateElement();
//     };

//     const upHandler = () => {
//         document.removeEventListener("mousemove", moveHandler);
//         document.removeEventListener("mouseup", upHandler);
//     };

//     document.addEventListener("mousemove", moveHandler);
//     document.addEventListener("mouseup", upHandler);
// }

startDragging(room, e) {
    if (room.locked) {
        this.showLockedMessage();
        return;
    }

    const startX = e.clientX;
    const startY = e.clientY;
    const startBounds = { ...room.bounds };
    
    // Get all connected rooms recursively
    const getAllConnectedRooms = (roomId, visited = new Set()) => {
        if (visited.has(roomId)) return [];
        visited.add(roomId);
        
        const connected = [];
        const directConnections = this.dockedRooms.get(roomId) || [];
        
        directConnections.forEach(({ room: dockedRoom }) => {
            connected.push(dockedRoom);
            // Get rooms docked to this room recursively
            const subConnected = getAllConnectedRooms(dockedRoom.id, visited);
            connected.push(...subConnected);
        });
        
        return connected;
    };

    // Get all connected rooms at the start
    const connectedRooms = getAllConnectedRooms(room.id);

    const moveHandler = (e) => {
        const dx = (e.clientX - startX) / this.scale;
        const dy = (e.clientY - startY) / this.scale;

        // Calculate new position with grid snapping
        const newX = this.snapToGrid(startBounds.x + dx, this.cellSize);
        const newY = this.snapToGrid(startBounds.y + dy, this.cellSize);

        // Move the main room
        room.bounds.x = newX;
        room.bounds.y = newY;
        room.updateElement();

        // Move all connected rooms while maintaining their relative positions
        connectedRooms.forEach(connectedRoom => {
            const docking = this.dockedRooms.get(connectedRoom.id)?.[0];
            if (docking) {
                const offset = this.calculateDockOffset(connectedRoom, docking.room, docking.position);
                connectedRoom.bounds.x = docking.room.bounds.x + offset.x;
                connectedRoom.bounds.y = docking.room.bounds.y + offset.y;
                connectedRoom.updateElement();
            }
        });
    };

    const upHandler = () => {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', upHandler);
    };

    document.addEventListener('mousemove', moveHandler);
    document.addEventListener('mouseup', upHandler);
}

// startDragging(room, e) {
//     if (room.locked) {
//         this.showLockedMessage();
//         return;
//     }

//     const startX = e.clientX;
//     const startY = e.clientY;
//     const startBounds = { ...room.bounds };
//     let dockedRooms = this.dockedRooms.get(room.id) || [];

//     const moveHandler = (e) => {
//         const dx = (e.clientX - startX) / this.scale;
//         const dy = (e.clientY - startY) / this.scale;

//         // Calculate new position
//         const newX = this.snapToGrid(startBounds.x + dx, this.cellSize);
//         const newY = this.snapToGrid(startBounds.y + dy, this.cellSize);

//         // Check for docking if not already docked and Shift is held
//         if (!dockedRooms.length && e.shiftKey) {
//             const dockResult = this.checkForDocking(room, newX, newY);
//             if (dockResult) {
//                 dockedRooms = [dockResult];
//                 this.dockedRooms.set(room.id, dockedRooms);
                
//                 // Visual feedback
//                 room.element.classList.add('docked');
//                 dockResult.room.element.classList.add('docked');
//             }
//         }

//         // Move the room
//         room.bounds.x = newX;
//         room.bounds.y = newY;
//         room.updateElement();

//         // Move docked rooms
//         if (dockedRooms.length && !this.isDraggingDocked) {
//             this.isDraggingDocked = true;
//             dockedRooms.forEach(({ room: dockedRoom, edge }) => {
//                 const offset = this.calculateDockOffset(room, dockedRoom, edge);
//                 dockedRoom.bounds.x = newX + offset.x;
//                 dockedRoom.bounds.y = newY + offset.y;
//                 dockedRoom.updateElement();
//             });
//             this.isDraggingDocked = false;
//         }
//     };

//     const upHandler = () => {
//         document.removeEventListener('mousemove', moveHandler);
//         document.removeEventListener('mouseup', upHandler);
//     };

//     document.addEventListener('mousemove', moveHandler);
//     document.addEventListener('mouseup', upHandler);
// }
        

startResizing(room, handle, e) {
    if (room.locked) {
        this.showLockedMessage();
        return;
    }
    
    const startX = e.clientX;
    const startY = e.clientY;
    const startBounds = { ...room.bounds };
    // Store initial points with their absolute positions
    const startPoints = room.points ? room.points.map(p => ({
        x: p.x + startBounds.x, // Store absolute coordinates
        y: p.y + startBounds.y
    })) : null;

    const moveHandler = (e) => {
        const dx = (e.clientX - startX) / this.scale;
        const dy = (e.clientY - startY) / this.scale;

        // Calculate new bounds
        let newX = startBounds.x;
        let newY = startBounds.y;
        let newWidth = startBounds.width;
        let newHeight = startBounds.height;

        if (handle.includes('e')) {
            newWidth = this.snapToGrid(startBounds.width + dx, this.cellSize);
        }
        if (handle.includes('w')) {
            const snappedDx = this.snapToGrid(dx, this.cellSize);
            newX = startBounds.x + snappedDx;
            newWidth = startBounds.width - snappedDx;
        }
        if (handle.includes('s')) {
            newHeight = this.snapToGrid(startBounds.height + dy, this.cellSize);
        }
        if (handle.includes('n')) {
            const snappedDy = this.snapToGrid(dy, this.cellSize);
            newY = startBounds.y + snappedDy;
            newHeight = startBounds.height - snappedDy;
        }

        // Update room bounds
        // room.bounds.x = newX;
        // room.bounds.y = newY;
        // room.bounds.width = Math.max(newWidth, this.cellSize || 20);
        // room.bounds.height = Math.max(newHeight, this.cellSize || 20);

        // Update room bounds
room.bounds.x = newX;
room.bounds.y = newY;

if (room.name.startsWith("Prop-")) {
    // Props can be any size, just prevent negative values
    room.bounds.width = Math.max(newWidth, 1);
    room.bounds.height = Math.max(newHeight, 1);
} else {
    // Regular rooms maintain minimum cell size
    room.bounds.width = Math.max(newWidth, this.cellSize || 20);
    room.bounds.height = Math.max(newHeight, this.cellSize || 20);
}

        // Update polygon points if this is a polygon room
        if (room.shape === 'polygon' && startPoints) {
            // Calculate scale factors
            const scaleX = room.bounds.width / startBounds.width;
            const scaleY = room.bounds.height / startBounds.height;

            // Update points while maintaining relative positions
            room.points = startPoints.map(p => ({
                x: ((p.x - startBounds.x) * scaleX) + (room.bounds.x - startBounds.x),
                y: ((p.y - startBounds.y) * scaleY) + (room.bounds.y - startBounds.y)
            }));
        }

        room.updateElement();
    };

    const upHandler = () => {
        document.removeEventListener('mousemove', moveHandler);
        document.removeEventListener('mouseup', upHandler);
    };

    document.addEventListener('mousemove', moveHandler);
    document.addEventListener('mouseup', upHandler);
}

handleMouseDown(e) {
          // Middle mouse button (wheel) press for panning
          if (e.button === 1) {
            // 1 is middle mouse button
            e.preventDefault(); // Prevent default middle-click behavior
            this.isDragging = true;
            this.dragStart = { x: e.clientX, y: e.clientY };
            const wrapper = document.getElementById("canvasWrapper");
            wrapper.style.cursor = "grabbing";
            return;
          }

          // Handle regular tools (rectangle and circle)
          if (
            ["rectangle", "circle"].includes(this.currentTool) &&
            e.button === 0
          ) {
            const wrapper = document.getElementById("canvasWrapper");
            const rect = wrapper.getBoundingClientRect();
            const x = (e.clientX - rect.left - this.offset.x) / this.scale;
            const y = (e.clientY - rect.top - this.offset.y) / this.scale;

            let roomSize;
            if (this.cellSize) {
              roomSize = this.cellSize;
            } else {
              roomSize = 100;
            }

            const room = new Room(
              Date.now(),
              {
                x: x - roomSize / 2,
                y: y - roomSize / 2,
                width: roomSize,
                height: roomSize
              },
              "",
              this.currentTool
            );

            this.rooms.push(room);
            const roomElement = room.createDOMElement(this);
            document
              .querySelector(".canvas-container")
              .appendChild(roomElement);
            room.updateEditState(true);
            this.layersPanel.updateLayersList();
            this.selectedRoomId = room.id;
          }
        }

        cleanupWallTool() {
          const wrapper = document.getElementById("canvasWrapper");
          if (this.wallClickHandler) {
            wrapper.removeEventListener("click", this.wallClickHandler);
            this.wallClickHandler = null;
          }
          this.isDrawingPolygon = false;
          this.polygonPoints = [];
          if (this.polygonPreviewElement) {
            this.polygonPreviewElement.remove();
            this.polygonPreviewElement = null;
          }
        }

        handleMouseMove(e) {
          if (this.isDragging) {
            const dx = e.clientX - this.dragStart.x;
            const dy = e.clientY - this.dragStart.y;

            this.offset.x += dx;
            this.offset.y += dy;

            this.dragStart = { x: e.clientX, y: e.clientY };

            // Update room positions
            this.rooms.forEach((room) => {
              room.updateElement(this.scale, this.offset);
            });

            // Update marker positions
            this.updateMarkerPositions();

            // Handle polygon preview if active
            if (this.isDrawingPolygon) {
              const rect = e.target.getBoundingClientRect();
              this.previewPoint = {
                x: (e.clientX - rect.left - this.offset.x) / this.scale,
                y: (e.clientY - rect.top - this.offset.y) / this.scale
              };
              this.updatePolygonPreview();
            }

            this.render();
          }
        }

        // Update handleMouseUp to reset cursor
        handleMouseUp(e) {
          if (this.isDragging) {
            this.isDragging = false;
            const wrapper = document.getElementById("canvasWrapper");
            wrapper.style.cursor =
              this.currentTool === "wall" ? "crosshair" : "default";
          }
        }

        // Add click handler for middle mouse button clicks
        setupMiddleClickHandlers() {
          const wrapper = document.getElementById("canvasWrapper");
          let lastClickTime = 0;
          const doubleClickDelay = 300; // milliseconds

          wrapper.addEventListener("auxclick", (e) => {
            if (e.button === 1) {
              // Middle mouse button
              e.preventDefault();
              const currentTime = new Date().getTime();

              if (currentTime - lastClickTime < doubleClickDelay) {
                // Double click - fit to view
                // this.zoomToFit();
                this.centerMap();
              } 
              // else {
              //   // Single click - center map
              //   this.centerMap();
              // }

              lastClickTime = currentTime;
            }
          });
        }

        handleWheel(e) {
          e.preventDefault();
          const delta = e.deltaY * -0.001;
          const newScale = Math.min(Math.max(0.1, this.scale + delta), 4);

          // Get mouse position relative to canvas
          const rect = this.canvas.getBoundingClientRect();
          const mouseX = e.clientX - rect.left;
          const mouseY = e.clientY - rect.top;

          // Calculate the position under the mouse in image coordinates
          const imageX = (mouseX - this.offset.x) / this.scale;
          const imageY = (mouseY - this.offset.y) / this.scale;

          // Update the scale
          this.scale = newScale;

          // Calculate new offset to keep the same image position under the mouse
          this.offset.x = mouseX - imageX * this.scale;
          this.offset.y = mouseY - imageY * this.scale;

          // Update all room positions when zooming
          this.rooms.forEach((room) => room.updateElement());

          // Update all markers
          this.markers.forEach((marker) => {
            this.updateMarkerPosition(marker);
            if (marker.type === "encounter" && marker.data.monster) {
              // Additional zoom handling for encounter markers
              const token = marker.element.querySelector(".monster-token");
              if (token) {
                token.style.transform = `scale(${this.scale})`;
                token.style.transformOrigin = "center";
              }
            }
          });

          // Update player start marker if it exists
          if (this.playerStart) {
            this.updateMarkerPosition(this.playerStart);
          }

          // In handleWheel method, after updating markers
this.markers.forEach(marker => {
    if (marker.type === 'teleport' && marker.data.isPointA && marker.data.pairedMarker) {
        this.updateTeleportConnection(marker, marker.data.pairedMarker);
    }
});

          this.render();
        }

        centerMap() {
          if (!this.baseImage) return;

          const container = this.canvas.parentElement;
          const scaleX = container.clientWidth / this.baseImage.width;
          const scaleY = container.clientHeight / this.baseImage.height;
          this.scale = Math.min(scaleX, scaleY, 1);

          this.offset = {
            x: (container.clientWidth - this.baseImage.width * this.scale) / 2,
            y: (container.clientHeight - this.baseImage.height * this.scale) / 2
          };

          // Update all room positions
          this.rooms.forEach((room) => room.updateElement());
          this.render();
        }

        render() {
    if (!this.ctx || !this.baseImage) return;

    // Clear canvas
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

    // Draw base image
    this.ctx.save();
    this.ctx.translate(this.offset.x, this.offset.y);
    this.ctx.scale(this.scale, this.scale);
    this.ctx.drawImage(this.baseImage, 0, 0);

    // Draw grid
    if (this.cellSize) {
        this.ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        this.ctx.lineWidth = 0.5;

        for (let x = 0; x < this.baseImage.width; x += this.cellSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(x, 0);
            this.ctx.lineTo(x, this.baseImage.height);
            this.ctx.stroke();
        }

        for (let y = 0; y < this.baseImage.height; y += this.cellSize) {
            this.ctx.beginPath();
            this.ctx.moveTo(0, y);
            this.ctx.lineTo(this.baseImage.width, y);
            this.ctx.stroke();
        }
    }

    this.ctx.restore();
}

        editRoom(room) {
            if (room.locked) {
        this.showLockedMessage();
        return;
    }
          this.rooms.forEach((r) => {
            if (r !== room) {
              r.updateEditState(false);
            }
          });

          // Enable editing for the selected room
          room.updateEditState(true);
          room.finalized = false;
          const roomElement = document.getElementById(`room-${room.id}`);
          if (roomElement) {
            roomElement.style.pointerEvents = "auto";
            roomElement.style.opacity = "1";
          }
          this.layersPanel.updateLayersList();
        }

        deleteRoom(room) {
            if (room.locked) {
        this.showLockedMessage();
        return;
    }
          const index = this.rooms.indexOf(room);
          if (index > -1) {
            this.rooms.splice(index, 1);
            const roomElement = document.getElementById(`room-${room.id}`);
            if (roomElement) {
              roomElement.remove();
            }
            this.layersPanel.updateLayersList();
          }
        }

        updateMarkerPositions() {
          this.markers.forEach((marker) => {
            if (marker.element) {
              // Update position
              marker.element.style.left = `${
                marker.x * this.scale + this.offset.x
              }px`;
              marker.element.style.top = `${
                marker.y * this.scale + this.offset.y
              }px`;

              // Update zoom scale
              this.updateMarkerZoom(marker);

              // Handle teleport connections if present
              if (
                marker.type === "teleport" &&
                marker.data.isPointA &&
                marker.data.pairedMarker &&
                marker.connection
              ) {
                this.updateTeleportConnection(marker, marker.data.pairedMarker);
              }
            }
          });

          if (this.playerStart && this.playerStart.element) {
            this.playerStart.element.style.left = `${
              this.playerStart.x * this.scale + this.offset.x
            }px`;
            this.playerStart.element.style.top = `${
              this.playerStart.y * this.scale + this.offset.y
            }px`;
            this.updateMarkerZoom(this.playerStart);
          }
        }

        createTeleportConnection(pointA, pointB) {

  
  const connection = document.createElement("div");
  connection.className = "teleport-connection";
  connection.id = `teleport-connection-${pointA.id}`;
  document.querySelector(".canvas-container").appendChild(connection);
  return connection;
}

        // Add method to update the visual connection
updateTeleportConnection(pointA, pointB) {
    if (!pointA || !pointB || !pointA.connection) return;

    const connection = pointA.connection;
    const containerRect = document
        .querySelector(".canvas-container")
        .getBoundingClientRect();

    const x1 = pointA.x * this.scale + this.offset.x;
    const y1 = pointA.y * this.scale + this.offset.y;
    const x2 = pointB.x * this.scale + this.offset.x;
    const y2 = pointB.y * this.scale + this.offset.y;

    const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
    const angle = (Math.atan2(y2 - y1, x2 - x1) * 180) / Math.PI;

    connection.style.width = `${length}px`;
    connection.style.left = `${x1}px`;
    connection.style.top = `${y1}px`;
    connection.style.transform = `rotate(${angle}deg)`;
}

        updateTeleportConnections() {
//   console.log("Updating all teleport connections");
  this.markers.forEach((marker) => {
    if (marker.type === "teleport") {
      console.log("Checking marker:", {
        id: marker.id,
        isPointA: marker.data.isPointA,
        hasPair: marker.data.hasPair,
        hasPairedMarker: !!marker.data.pairedMarker,
        attribute: marker.element.getAttribute('data-teleport-point')
      });
      
      if (marker.data.pairedMarker && marker.data.isPointA) {
        if (marker.connection) {
          marker.connection.remove();
        }
        marker.connection = this.createTeleportConnection(
          marker,
          marker.data.pairedMarker
        );
        this.updateTeleportConnection(marker, marker.data.pairedMarker);
      }
    }
  });
}

// Add to MapEditor class
async showStructureContextMenu(structure, event) {
    event.preventDefault();
    
    const dialog = document.createElement('sl-dialog');
    dialog.label = `${structure.type === 'wall' ? 'Wall' : 'Room'} Options`;

    dialog.innerHTML = `
        <div style="display: flex; flex-direction: column; gap: 12px;">
            <sl-button class="assign-texture-btn">
                <span class="material-icons" slot="prefix">texture</span>
                Assign Texture
            </sl-button>
            ${structure.textureAssignments?.size ? `
                <sl-button class="clear-texture-btn" variant="danger">
                    <span class="material-icons" slot="prefix">clear</span>
                    Clear Texture
                </sl-button>
            ` : ''}
        </div>
    `;

    document.body.appendChild(dialog);

    // Handle texture assignment
    dialog.querySelector('.assign-texture-btn').addEventListener('click', async () => {
        dialog.hide();
        const texture = await this.resourceManager.showTextureSelectionDialog(structure);
        if (texture) {
            // Handle texture assignment - we'll implement this next
            console.log('Selected texture:', texture);
            // await this.assignTexture(structure, texture);
        }
    });

    // Handle texture clearing if button exists
    dialog.querySelector('.clear-texture-btn')?.addEventListener('click', () => {
        if (structure.textureAssignments) {
            structure.textureAssignments.clear();
            // We'll implement visual updates in the next step
        }
        dialog.hide();
    });

    dialog.addEventListener('sl-after-hide', () => {
        dialog.remove();
    });

    dialog.show();
}


        addMarker(type, x, y, data = {}) {
          // Check if map is loaded
          if (!this.baseImage) {
            alert("Please load a map before placing markers");
            return null;
          }


        if (type === "door") {
        console.log('Finding nearest structure for door placement');
        const nearestStructure = this.rooms.find(room => {
            return this.isNearWall(x, y, room);  // Keep using isNearWall since it works for both
        });
    
        if (nearestStructure) {
            console.log('Found nearest structure:', nearestStructure);
            // Use snapToStructure instead of snapToWall to get rotation info
            const snappedPosition = this.snapToStructure(x, y, nearestStructure);
            console.log('Snapped position:', snappedPosition);
            
            // Get texture from resource manager
            const textureCategory = "doors";
            console.log('Getting door texture from resource manager');
            const texture = this.resourceManager.getSelectedTexture(textureCategory);
            
            if (!texture) {
                console.warn('No door texture available');
                alert('No door textures available. Please add some in the Resource Manager.');
                return null;
            }
    
            console.log('Creating door marker with texture:', texture);
            const marker = this.createMarker("door", snappedPosition.x, snappedPosition.y, {
                texture: texture,
                door: { 
                    position: snappedPosition,  // This now includes edge and rotation
                    isOpen: false
                },
                parentStructure: nearestStructure
            });
            this.markers.push(marker);
            return marker;
        } else {
            console.warn('No nearby structure found for door placement');
            alert("Doors must be placed on a wall or room");
            return null;
        }
    }

          // Handle player start point (only one allowed)
          if (type === "player-start") {
            if (this.playerStart) {
              this.removeMarker(this.playerStart);
            }
            this.playerStart = this.createMarker(type, x, y, data);
            return this.playerStart;
          }




        if (type === "teleport") {
    // Place Point A
    if (!this.pendingTeleportPair) {
        // console.log("Creating Point A");
        const teleportA = this.createMarker(type, x, y, {
            isPointA: true,
            pairId: Date.now()
        });
        console.log("Point A created:", {
            isPointA: teleportA.data.isPointA,
            attribute: teleportA.element.getAttribute('data-teleport-point')
        });
        this.pendingTeleportPair = teleportA;
        this.markers.push(teleportA);
        return teleportA;
    }
    // Place Point B
    else if (this.pendingTeleportPair && !this.pendingTeleportPair.data.hasPair) {
        // console.log("Creating Point B");
        const teleportB = this.createMarker(type, x, y, {
            isPointA: false,
            pairId: this.pendingTeleportPair.data.pairId
        });
        
        // Debug log right after creation
        console.log("Point B immediately after creation:", {
            isPointA: teleportB.data.isPointA,
            attribute: teleportB.element.getAttribute('data-teleport-point'),
            elementHTML: teleportB.element.outerHTML
        });

        // Create and store the connection line
        const connection = document.createElement("div");
        connection.className = "teleport-connection";
        connection.id = `teleport-connection-${this.pendingTeleportPair.data.pairId}`;
        document.querySelector(".canvas-container").appendChild(connection);

        // Link the pairs and store the connection
        this.pendingTeleportPair.data.pairedMarker = teleportB;
        this.pendingTeleportPair.data.hasPair = true;
        this.pendingTeleportPair.connection = connection;
        teleportB.data.pairedMarker = this.pendingTeleportPair;
        teleportB.data.hasPair = true;  // Add this line to ensure B knows it's paired

        // Debug log after connection setup
        console.log("After connection setup:", {
            pointA: {
                isPointA: this.pendingTeleportPair.data.isPointA,
                hasPair: this.pendingTeleportPair.data.hasPair,
                attribute: this.pendingTeleportPair.element.getAttribute('data-teleport-point')
            },
            pointB: {
                isPointA: teleportB.data.isPointA,
                hasPair: teleportB.data.hasPair,
                attribute: teleportB.element.getAttribute('data-teleport-point')
            }
        });

        // Update the connection line position
        this.updateTeleportConnection(this.pendingTeleportPair, teleportB);
        this.markers.push(teleportB);

        // Reset state for next pair
        this.pendingTeleportPair = null;

        // Reset tool to default teleport state
        this.setTool("marker-teleport");
        return teleportB;
    }
    return null;
}

          if (type === "encounter" && data.monster?.image) {
            const marker = this.createTokenMarker(type, x, y, data);
            this.markers.push(marker);
            return marker;
          }

          // Regular markers
          const marker = this.createMarker(type, x, y, data);
          this.markers.push(marker);
          return marker;
        }

        // Add this new method to MapEditor class
        startMarkerDragging(marker, e) {
          // Changed name from startDragging to startMarkerDragging
          if (!this.isMarkerEditMode) return;

          const startX = e.clientX;
          const startY = e.clientY;
          const startMarkerX = marker.x;
          const startMarkerY = marker.y;

          const moveHandler = (moveEvent) => {
            const dx = (moveEvent.clientX - startX) / this.scale;
            const dy = (moveEvent.clientY - startY) / this.scale;

            marker.x = startMarkerX + dx;
            marker.y = startMarkerY + dy;

            this.updateMarkerPosition(marker);

            // Update teleport connections if needed
            if (marker.type === "teleport") {
              this.updateTeleportConnections();
            }
          };

          const upHandler = () => {
            document.removeEventListener("mousemove", moveHandler);
            document.removeEventListener("mouseup", upHandler);
          };

          document.addEventListener("mousemove", moveHandler);
          document.addEventListener("mouseup", upHandler);
        }

        toggleMarkerEditMode() {
          this.isMarkerEditMode = !this.isMarkerEditMode;

          // Update the button state
          const editMarkerBtn = document.getElementById("editMarkerTool");
          if (editMarkerBtn) {
            editMarkerBtn.classList.toggle("active", this.isMarkerEditMode);
          }

          // Update all markers
          this.markers.forEach((marker) => {
            if (marker.element) {
              marker.element.classList.toggle("editing", this.isMarkerEditMode);
              // Only allow dragging in edit mode
              marker.element.style.cursor = this.isMarkerEditMode
                ? "move"
                : "pointer";
            }
          });

          // Update player start marker if it exists
          if (this.playerStart && this.playerStart.element) {
            this.playerStart.element.classList.toggle(
              "editing",
              this.isMarkerEditMode
            );
            this.playerStart.element.style.cursor = this.isMarkerEditMode
              ? "move"
              : "pointer";
          }
        }

        getMonsterSizeInSquares(size) {
          // Add debug logging
          console.log("Getting monster size for:", size);

          // Handle undefined/null size
          if (!size) {
            console.log("Size undefined, defaulting to medium");
            return 1; // Default to medium size
          }

          const sizeMap = {
            tiny: 0.5, // 2.5ft
            small: 1, // 5ft
            medium: 1, // 5ft
            large: 2, // 10ft (2x2)
            huge: 3, // 15ft (3x3)
            gargantuan: 4 // 20ft (4x4)
          };

          const calculatedSize = sizeMap[size.toLowerCase()] || 1;
          console.log("Calculated size:", calculatedSize);
          return calculatedSize;
        }


//         getMonsterTokenData(marker) {
//     console.log("Processing marker:", marker);

//     if (!marker || !marker.data || !marker.data.monster) {
//         console.log("Invalid marker data");
//         return null;
//     }

//     // Get correct token image source
//     const tokenSource = marker.data.monster.token.data || marker.data.monster.token.url;
//     console.log("Token image source:", tokenSource);

//     const monsterSize = this.getMonsterSizeInSquares(marker.data.monster.basic.size || "medium");

//     const tokenData = {
//         x: marker.x,
//         y: marker.y,
//         size: monsterSize,
//         image: tokenSource,
//         type: "monster",
//         name: marker.data.monster.name || "Unknown Monster",
//         height: 2 * monsterSize
//     };

//     console.log("Created token data:", tokenData);
//     return tokenData;
// }

getMonsterTokenData(marker) {
    console.log("Processing marker:", {
        type: marker.type,
        data: marker.data,
        hasMonster: !!marker.data?.monster,
        hasToken: !!marker.data?.monster?.token,
        tokenData: marker.data?.monster?.token?.data,
        tokenUrl: marker.data?.monster?.token?.url
    });

    if (!marker || !marker.data || !marker.data.monster) {
        console.log("Invalid marker data");
        return null;
    }

    if (!marker.data.monster.token || (!marker.data.monster.token.data && !marker.data.monster.token.url)) {
        console.log("No valid token data found");
        return null;
    }

    // Get correct token image source
    const tokenSource = marker.data.monster.token.data || marker.data.monster.token.url;
    console.log("Token image source type:", {
        isBase64: tokenSource.startsWith('data:'),
        length: tokenSource.length,
        preview: tokenSource.substring(0, 100) + '...'
    });

    const monsterSize = this.getMonsterSizeInSquares(marker.data.monster.basic.size || "medium");
    const tokenData = {
        x: marker.x,
        y: marker.y,
        size: monsterSize,
        image: tokenSource,
        type: "monster",
        name: marker.data.monster.basic?.name || "Unknown Monster",
        height: 2 * monsterSize
    };

    console.log("Created token data:", {
        position: `${tokenData.x}, ${tokenData.y}`,
        size: tokenData.size,
        height: tokenData.height,
        hasImage: !!tokenData.image
    });

    return tokenData;
}

        
        updateMarkerAppearance(marker) {
          if (marker.data.monster?.token) {
            const tokenSource =
              marker.data.monster.token.data || marker.data.monster.token.url;
            const monsterSize = this.getMonsterSizeInSquares(
              marker.data.monster.basic.size
            );

            // Use the existing cellSize property
            const cellSize = this.cellSize || 32; // Fallback to 32 if cellSize not calculated yet
            const totalSize = cellSize * monsterSize; // This will be both width and height

            // Make the token square and centered
            marker.element.innerHTML = `
            <div class="monster-token" style="
                width: ${totalSize}px; 
                height: ${totalSize}px; 
                border-radius: 10%; 
                border: 2px solid #f44336; 
                overflow: hidden;
                display: flex;
                align-items: center;
                justify-content: center;
                position: absolute;
                left: -${totalSize / 2}px;
                top: -${totalSize / 2}px;
                transform-origin: center;
                transform: scale(${this.scale}); /* Add map scaling */
            ">
                <img src="${tokenSource}" 
                     style="width: 100%; height: 100%; object-fit: cover;"
                     onerror="this.onerror=null; this.parentElement.innerHTML='<span class=\'material-icons\' style=\'font-size: ${
                       totalSize * 0.75
                     }px;\'>local_fire_department</span>';" />
            </div>
        `;

            // Update position with current scale and offset
            this.updateMarkerPosition(marker);
          }
        }

        // Add new method to handle zoom scaling
        updateMarkerZoom(marker) {
          if (!marker.element) return;

          const token = marker.element.querySelector(".monster-token");
          if (token) {
            token.style.transform = `scale(${this.scale})`;
            token.style.transformOrigin = "center";
          }
        }

        // Helper method to create marker elements
        createMarker(type, x, y, data) {
          const marker = {
            id: Date.now(),
            type,
            x,
            y,
            data,
            element: null
          };

          const markerElement = document.createElement("div");
          markerElement.className = `map-marker marker-${type}`;
          markerElement.id = `marker-${marker.id}`;

          if (data.texture) {
        console.log('Applying texture to marker:', data.texture);
        // You might want to add custom styling here based on the texture
    }

          // Set up drag handling with edit mode check

          markerElement.addEventListener("mousedown", (e) => {
            if (!this.isMarkerEditMode) return; // Only allow dragging in edit mode
            if (e.button !== 0) return; // Only handle left click

            e.preventDefault();
            e.stopPropagation();

            this.startMarkerDragging(marker, e); // This calls the separate method with all the dragging logic
          });

        //   console.log("Creating marker with type:", type);
          // Handle encounter markers with monster data
          if (type === "encounter" && data.monster?.token) {
            const tokenSource =
              data.monster.token.data || data.monster.token.url;
            const monsterSize = this.getMonsterSizeInSquares(
              data.monster.basic.size
            );
            const baseSize = 32;
            const scaledSize = baseSize * monsterSize;

            markerElement.innerHTML = `
        <div class="monster-token" style="
            width: ${scaledSize}px !important;
            height: ${scaledSize}px !important;
            border-radius: 10%;
            border: 2px solid #f44336;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            left: -${scaledSize / 2}px;
            top: -${scaledSize / 2}px;
            transform-origin: center;
            transform: scale(${this.scale}); /* Add map scaling */
        ">
            <img src="${tokenSource}"
                 style="width: 100%; height: 100%; object-fit: cover;"
                 onerror="this.onerror=null; this.parentElement.innerHTML='<span class=\\'material-icons\\' style=\\'font-size: ${
                   scaledSize * 0.75
                 }px;\\'>local_fire_department</span>';" />
        </div>
    `;
          } else {
            // Add the default icon based on type
            const icon = {
  "player-start": "person_pin_circle",
  encounter: "local_fire_department", 
  treasure: "workspace_premium",
  trap: "warning",
  teleport: "swap_calls",
  door: "door_front"  // Add this line
}[type] || "location_on";

            markerElement.innerHTML = `<span class="material-icons">${icon}</span>`;
          }

          // Set initial cursor based on edit mode
          markerElement.style.cursor = this.isMarkerEditMode
            ? "move"
            : "pointer";


        if (type === "teleport") {
  const pointType = data.isPointA ? "a" : "b";
  console.log("Before setting teleport point type:", {
    isPointA: data.isPointA,
    pointType: pointType
    // currentAttr: markerElement.getAttribute('data-teleport-point')
  });
  
  markerElement.setAttribute("data-teleport-point", pointType);
  
  console.log("After setting teleport point type:", {
    isPointA: data.isPointA,
    pointType: pointType,
    newAttr: markerElement.getAttribute('data-teleport-point'),
    element: markerElement.outerHTML
  });
}

if (type === "door") {
    markerElement.style.transform = `rotate(${data.door?.position?.rotation || 0}deg)`;
}

          // Add context menu handler
          markerElement.addEventListener("contextmenu", (e) => {
            e.preventDefault(); // Prevent default context menu
            this.showMarkerContextMenu(marker, e);
          });

          // Position marker
          markerElement.style.left = `${x * this.scale + this.offset.x}px`;
          markerElement.style.top = `${y * this.scale + this.offset.y}px`;

          // Add hover effects
          markerElement.addEventListener("mouseenter", () => {
            markerElement.classList.add("highlighted");
            if (marker.data.pairedMarker) {
              // Highlight paired teleport point
              marker.data.pairedMarker.element.classList.add("highlighted");
            }
          });

          markerElement.addEventListener("mouseleave", () => {
            markerElement.classList.remove("highlighted");
            if (marker.data.pairedMarker) {
              marker.data.pairedMarker.element.classList.remove("highlighted");
            }
          });

          document
            .querySelector(".canvas-container")
            .appendChild(markerElement);
          marker.element = markerElement;

          markerElement.addEventListener("mouseover", (e) => {
            console.log("Mouse over marker:", marker.type);
          });

          return marker;
        }

        updateMarkerPosition(marker) {
          if (marker.element) {
            const x = marker.x * this.scale + this.offset.x;
            const y = marker.y * this.scale + this.offset.y;

            marker.element.style.left = `${x}px`;
            marker.element.style.top = `${y}px`;

            // Scale the token based on current zoom
            const token = marker.element.querySelector(".monster-token");
            if (token) {
              token.style.transform = `scale(${this.scale})`;
            }
          }
        }

        updateMarkerPositions() {
          this.markers.forEach((marker) => {
            if (marker.element) {
              marker.element.style.left = `${
                marker.x * this.scale + this.offset.x
              }px`;
              marker.element.style.top = `${
                marker.y * this.scale + this.offset.y
              }px`;

              // Update connection line if this is a teleport point A
              if (
                marker.type === "teleport" &&
                marker.data.isPointA &&
                marker.data.pairedMarker &&
                marker.connection
              ) {
                this.updateTeleportConnection(marker, marker.data.pairedMarker);
              }
            }
          });

          if (this.playerStart && this.playerStart.element) {
            this.playerStart.element.style.left = `${
              this.playerStart.x * this.scale + this.offset.x
            }px`;
            this.playerStart.element.style.top = `${
              this.playerStart.y * this.scale + this.offset.y
            }px`;
          }
        }

removeMarker(marker) {
  if (marker.element) {
    marker.element.remove();
  }

  // Special handling for teleport markers
  if (marker.type === 'teleport') {
    // Remove the connection line if it exists
    if (marker.connection) {
      marker.connection.remove();
    }
    // If this marker has a pair, clean up the pair's reference and connection
    if (marker.data.pairedMarker) {
      const pair = marker.data.pairedMarker;
      pair.data.pairedMarker = null;
      pair.data.hasPair = false;
      if (pair.connection) {
        pair.connection.remove();
        pair.connection = null;
      }
    }
    // Reset the pending teleport pair if this was point A
    if (this.pendingTeleportPair === marker) {
      this.pendingTeleportPair = null;
    }
  }

  // Remove from markers array or reset player start
  if (marker.type === 'player-start') {
    this.playerStart = null;
  } else {
    const index = this.markers.indexOf(marker);
    if (index > -1) {
      this.markers.splice(index, 1);
    }
  }
}

        getMarkerTooltip(marker) {
          switch (marker.type) {
            case "player-start":
              return "Player Start Point";
            case "encounter":
              return marker.data.monster
                ? `Encounter: ${marker.data.monster.name} (CR ${marker.data.monster.cr})`
                : "Encounter Point";
            case "treasure":
              return marker.data.description || "Treasure";
            case "trap":
              return marker.data.description || "Trap";
            default:
              return "Map Marker";
          }
        }

showMarkerContextMenu(marker, event) {
        const dialog = document.createElement('sl-dialog');
        dialog.label = 'Marker Options';

        const canChangeTexture = (marker.type === 'door' || marker.type === 'prop') && this.resourceManager;

        let content = '<div style="display: flex; flex-direction: column; gap: 10px;">';

        if (canChangeTexture) {
          const textureCategory = marker.type === 'door' ? 'doors' : 'props';
          content += `
        <div style="border: 1px solid #444; padding: 12px; border-radius: 4px;">
            <label>Texture:</label>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(100px, 1fr)); gap: 8px; margin-top: 8px;">
                ${Array.from(this.resourceManager.resources.textures[textureCategory].entries()).map(([id, texture]) => `
                    <div class="texture-option" data-texture-id="${id}" 
                        style="cursor: pointer; border: 2px solid ${marker.data.texture?.id === id ? 'var(--sl-color-primary-600)' : 'transparent'}; 
                        padding: 4px; border-radius: 4px; position: relative;">
                        <img src="${texture.data}" style="width: 100%; height: 100px; object-fit: cover; border-radius: 2px;">
                        <div style="font-size: 0.8em; text-align: center; margin-top: 4px;">${texture.name}</div>
                        ${marker.data.texture?.id === id ? `
                            <span class="material-icons" style="position: absolute; top: 4px; right: 4px; color: #4CAF50; 
                                background: rgba(0,0,0,0.5); border-radius: 50%; padding: 2px;">
                                check_circle
                            </span>
                        ` : ''}
                    </div>
                `).join('')}
            </div>
        </div>
    `;
        }

        if (marker.type === 'teleport') {
          content += `
            <div style="margin-bottom: 12px;">
                <div style="font-weight: bold; margin-bottom: 4px;">Teleport Point ${marker.data.isPointA ? 'A' : 'B'}</div>
                <div style="color: #666;">
                    ${marker.data.hasPair ?
              `Connected to Point ${marker.data.isPointA ? 'B' : 'A'}` :
              'No connection - Place another point to connect'}
                </div>
            </div>
        `;
      } else if (marker.type === 'encounter') {
    if (marker.data.monster) {
        // Create monster URL using name and source
        const baseUrl = "https://5e.tools/bestiary.html";
        const monsterName = marker.data.monster.basic.name
            .toLowerCase()
            .replace(/\s+/g, "_");
        const sourceCode = "xphb"; // We could extract this from source data if available
        const monsterUrl = `${baseUrl}#${monsterName}_${sourceCode}`;

        content += `
            <div style="margin-bottom: 16px;">
                <div style="display: flex; gap: 16px; margin-bottom: 12px;">
                    ${marker.data.monster.token ? `
                        <div style="width: 100px; height: 100px; border-radius: 8px; border: 2px solid #f44336; overflow: hidden;">
                            <img src="${marker.data.monster.token.data || marker.data.monster.token.url}" 
                                 style="width: 100%; height: 100%; object-fit: cover;" />
                        </div>
                    ` : ""}
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 4px 0; font-size: 1.2em;">
                            <a href="${monsterUrl}" target="_blank" style="color: #2196F3; text-decoration: none;">
                                ${marker.data.monster.basic.name}
                                <span class="material-icons" style="font-size: 14px; vertical-align: middle;">open_in_new</span>
                            </a>
                        </h3>
                        <div style="color: #666; font-style: italic; margin-bottom: 8px;">
                            ${marker.data.monster.basic.size} ${marker.data.monster.basic.type}, 
                            ${marker.data.monster.basic.alignment}
                        </div>
                        <div style="color: #666;">
                            CR ${marker.data.monster.basic.cr} (${marker.data.monster.basic.xp} XP)
                        </div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 12px; text-align: center; background: #f5f5f5; padding: 8px; border-radius: 4px;">
                    <div>
                        <div style="font-weight: bold;">Armor Class</div>
                        <div>${marker.data.monster.stats.ac}</div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">Hit Points</div>
                        <div>${marker.data.monster.stats.hp.average} (${marker.data.monster.stats.hp.roll})</div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">Speed</div>
                        <div>${marker.data.monster.stats.speed}</div>
                    </div>
                </div>

                <div style="display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; text-align: center; background: #f5f5f5; padding: 8px; border-radius: 4px;">
                    <div>
                        <div style="font-weight: bold;">STR</div>
                        <div>${marker.data.monster.abilities.str.score} (${marker.data.monster.abilities.str.modifier >= 0 ? "+" : ""}${marker.data.monster.abilities.str.modifier})</div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">DEX</div>
                        <div>${marker.data.monster.abilities.dex.score} (${marker.data.monster.abilities.dex.modifier >= 0 ? "+" : ""}${marker.data.monster.abilities.dex.modifier})</div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">CON</div>
                        <div>${marker.data.monster.abilities.con.score} (${marker.data.monster.abilities.con.modifier >= 0 ? "+" : ""}${marker.data.monster.abilities.con.modifier})</div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">INT</div>
                        <div>${marker.data.monster.abilities.int.score} (${marker.data.monster.abilities.int.modifier >= 0 ? "+" : ""}${marker.data.monster.abilities.int.modifier})</div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">WIS</div>
                        <div>${marker.data.monster.abilities.wis.score} (${marker.data.monster.abilities.wis.modifier >= 0 ? "+" : ""}${marker.data.monster.abilities.wis.modifier})</div>
                    </div>
                    <div>
                        <div style="font-weight: bold;">CHA</div>
                        <div>${marker.data.monster.abilities.cha.score} (${marker.data.monster.abilities.cha.modifier >= 0 ? "+" : ""}${marker.data.monster.abilities.cha.modifier})</div>
                    </div>
                </div>
            </div>
        `;
    }

    // Buttons always show for encounter markers
    content += `
        <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
            ${marker.data.monster ? `
                <sl-button id="cloneMonster" size="small">
                    <span class="material-icons">content_copy</span>
                    Clone
                </sl-button>
            ` : ''}
            <sl-button id="linkMonster" size="small" style="grid-column: ${marker.data.monster ? 'auto' : '1 / -1'}">
                <span class="material-icons">link</span>
                ${marker.data.monster ? "Change" : "Add"} Monster
            </sl-button>
        </div>
    `;
} else if (["treasure", "trap"].includes(marker.type)) {
    content += `
        <sl-input id="markerDescription"
                 label="Description"
                 value="${marker.data.description || ""}">
        </sl-input>
    `;
}

content += "</div>";

// Add standardized footer with delete button
content += `
    <div slot="footer" style="display: flex; justify-content: space-between; align-items: center;">
        <div class="flex-spacer"></div>
        <sl-button class="delete-marker-btn" variant="danger">
            <span class="material-icons" style="margin-right: 4px;">delete</span>
            Remove ${marker.type.charAt(0).toUpperCase() + marker.type.slice(1)}
        </sl-button>
    </div>
`;

dialog.innerHTML = content;
document.body.appendChild(dialog);

        // Add texture selection handler
        const textureOptions = dialog.querySelectorAll('.texture-option');
        textureOptions.forEach(option => {
          option.addEventListener('click', () => {
            const textureId = option.dataset.textureId;
            const textureCategory = marker.type === 'door' ? 'doors' : 'props';
            const texture = this.resourceManager.resources.textures[textureCategory].get(textureId);
            if (texture) {
              marker.data.texture = texture;
              this.updateMarkerAppearance(marker);
              textureOptions.forEach(opt => opt.style.border = '2px solid transparent');
              option.style.border = '2px solid var(--sl-color-primary-600)';
            }
          });
        });


        // dialog.show();

        const deleteBtn = dialog.querySelector('.delete-marker-btn');
        if (deleteBtn) {
          deleteBtn.addEventListener('click', () => {
            this.removeMarker(marker);
            dialog.hide();
          });
        }

        // Add other existing event handlers
        const changeTextureBtn = dialog.querySelector('.change-texture-btn');
        if (changeTextureBtn) {
          changeTextureBtn.addEventListener('click', async () => {
            dialog.hide();
            const texture = await this.resourceManager.showTextureSelectionDialog({
              type: marker.type === 'door' ? 'door' : 'prop'
            });
            if (texture) {
              marker.data.texture = texture;
              this.updateMarkerAppearance(marker);
            }
          });
        }

        const cloneBtn = dialog.querySelector("#cloneMonster");
        if (cloneBtn) {
          cloneBtn.addEventListener("click", () => {
            this.monsterManager.cloneEncounter(marker);
            dialog.hide();
          });
        }

        const linkBtn = dialog.querySelector("#linkMonster");
        if (linkBtn) {
          linkBtn.addEventListener("click", () => {
            this.monsterManager.showMonsterSelector(marker);
            dialog.hide();
          });
        }

        const descInput = dialog.querySelector("#markerDescription");
        if (descInput) {
          descInput.addEventListener("sl-change", (e) => {
            marker.data.description = e.target.value;
          });
        }

        dialog.addEventListener("sl-after-hide", () => {
          dialog.remove();
        });

        dialog.show();
      }


                finalizeRoom(room) {
            room.finalized = true;
            room.updateEditState(false);

                // Generate new thumbnail after resizing
    room.createThumbnail();
            
            // Ensure room controls stay interactive
            const controls = room.element.querySelector('.room-controls');
            if (controls) {
                controls.style.pointerEvents = 'auto';
                controls.querySelectorAll('.material-icons').forEach(icon => {
                    icon.style.pointerEvents = 'auto';
                    icon.style.cursor = 'pointer';
                });
            }
            
            this.selectedRoomId = null;
            this.layersPanel.updateLayersList();
        }

        createTokenMesh(token) {
          // Create billboard material
          const spriteMaterial = new THREE.SpriteMaterial({
            map: new THREE.TextureLoader().load(token.image),
            transparent: true,
            sizeAttenuation: true
          });

          const sprite = new THREE.Sprite(spriteMaterial);

          // Scale based on token size and grid
          const scale = token.size * (this.cellSize / 50);
          sprite.scale.set(scale, scale, 1);

          // Position in world space
          const x = token.x / this.cellSize - boxWidth / 2;
          const z = token.y / this.cellSize - boxDepth / 2;
          sprite.position.set(x, token.height, z);

          return sprite;
        }

        createTextureFromRoom(textureRoom) {
          const canvas = document.createElement("canvas");
          const ctx = canvas.getContext("2d");
          canvas.width = textureRoom.bounds.width;
          canvas.height = textureRoom.bounds.height;

          // Draw the portion of the map that contains the texture
          ctx.drawImage(
            this.baseImage,
            textureRoom.bounds.x,
            textureRoom.bounds.y,
            textureRoom.bounds.width,
            textureRoom.bounds.height,
            0,
            0,
            canvas.width,
            canvas.height
          );

          const texture = new THREE.CanvasTexture(canvas);
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;

          // Calculate repeats based on grid cell size
          const horizontalRepeats = Math.round(
            textureRoom.bounds.width / this.cellSize
          );
          const verticalRepeats = Math.round(
            textureRoom.bounds.height / this.cellSize
          );

          texture.repeat.set(horizontalRepeats, verticalRepeats);
          texture.needsUpdate = true;

          return texture;
        }

        async init3DScene(updateStatus) {
          const renderState = {
            clippingEnabled: false // true
          };
          const scene = new THREE.Scene();
          scene.background = new THREE.Color(0x222222);

          this.tokens = [];

          // Add encounter markers to tokens array
// this.markers.forEach(marker => {
//     if (marker.type === "encounter" && marker.data.monster) {
//         console.log("Processing encounter marker for 3D:", marker);
        
//         const tokenData = this.getMonsterTokenData(marker);
//         if (tokenData) {
//             this.tokens.push(tokenData);
//             console.log("Added token data:", tokenData);
//         }
//     }
// });

// Add encounter markers to tokens array
console.log("Starting to process markers for tokens:", this.markers.length);
this.markers.forEach((marker, index) => {
    console.log(`Processing marker ${index}:`, {
        type: marker.type,
        hasMonster: !!marker.data?.monster
    });

    if (marker.type === "encounter" && marker.data?.monster) {
        console.log("Processing encounter marker for 3D:", {
            name: marker.data.monster.basic?.name,
            hasToken: !!marker.data.monster.token
        });
       
        const tokenData = this.getMonsterTokenData(marker);
        if (tokenData) {
            this.tokens.push(tokenData);
            console.log("Successfully added token data:", {
                name: tokenData.name,
                position: `${tokenData.x}, ${tokenData.y}`,
                size: tokenData.size
            });
        } else {
            console.log("Failed to get token data for marker");
        }
    }
});

console.log("Finished processing markers, total tokens:", this.tokens.length);

const camera = new THREE.PerspectiveCamera(
            75,
            (window.innerWidth * 0.75) / window.innerHeight,
            0.1,
            1000
          );
          camera.position.set(0, 2, 5);

        //  const sidebarContentWidth = document.querySelector(".sidebar-content");

          const renderer = new THREE.WebGLRenderer({ antialias: true });
          renderer.setSize(window.innerWidth * 0.95, window.innerHeight);
          renderer.shadowMap.enabled = true;

          const wallTextureRoom = this.rooms.find(
            (room) => room.name === "WallTexture"
          );
          const roomTextureRoom = this.rooms.find(
            (room) => room.name === "RoomTexture"
          );

          let wallTexture = null;
          let roomTexture = null;

          if (wallTextureRoom) {
            // console.log("Creating wall texture from room:", wallTextureRoom);
            wallTexture = this.createTextureFromRoom(wallTextureRoom);
          }

          // Create room texture if defined
          if (roomTextureRoom) {
            // console.log("Creating room texture from room:", roomTextureRoom);
            roomTexture = this.createTextureFromRoom(roomTextureRoom);
          }

          // Create floor texture
          const texture = new THREE.Texture(this.baseImage);
          texture.needsUpdate = true;
          texture.wrapS = THREE.RepeatWrapping;
          texture.wrapT = THREE.RepeatWrapping;

          // Create main block dimensions
          const boxWidth = this.baseImage.width / 50;
          const boxHeight = 4.5; // 4; // Wall height
          const boxDepth = this.baseImage.height / 50;

// Handle doors with textures
this.markers.forEach(marker => {
    if (marker.type === 'door' && marker.data.texture) {
        console.log('Creating 3D door with texture:', marker.data);
        const doorMesh = this.textureManager.createDoorMesh(
            marker,
            boxWidth,
            boxHeight,
            boxDepth
        );
        if (doorMesh) {
            scene.add(doorMesh);
            console.log('Door mesh added to scene');
        }
    }
});


          const createRoomGeometry = (room) => {
            const positions = [];
            const normals = [];
            const uvs = [];
            const indices = [];

            // Add at the start of createRoomGeometry:
            const isWall = room.type === "wall";
            console.log("Room geometry creation:", {
              roomName: room.name,
              roomType: room.type,
              isWall: isWall
            });

            switch (room.shape) {
              case "circle": {
    const segments = 32;
    const radius = Math.max(room.bounds.width, room.bounds.height) / 100;
    const centerX = (room.bounds.x + room.bounds.width/2) / 50 - boxWidth / 2;
    const centerZ = (room.bounds.y + room.bounds.height/2) / 50 - boxDepth / 2;

    if (isWall) {
        // For walls, create solid cylinder including top and bottom
        for (let i = 0; i <= segments; i++) {
            const theta = (i / segments) * Math.PI * 2;
            const x = Math.cos(theta);
            const z = Math.sin(theta);

            // Bottom vertices
            positions.push(
                centerX + radius * x,
                0,
                centerZ + radius * z
            );
            normals.push(x, 0, z);
            uvs.push(i / segments, 0);

            // Top vertices
            positions.push(
                centerX + radius * x,
                boxHeight,
                centerZ + radius * z
            );
            normals.push(x, 0, z);
            uvs.push(i / segments, 1);
        }

        // Create faces for cylinder walls
        for (let i = 0; i < segments; i++) {
            const base = i * 2;
            indices.push(
                base, base + 1, base + 2,
                base + 1, base + 3, base + 2
            );
        }

        // Add center vertices for top and bottom caps
        const bottomCenterIndex = positions.length / 3;
        positions.push(centerX, 0, centerZ);
        normals.push(0, -1, 0);
        uvs.push(0.5, 0.5);

        const topCenterIndex = positions.length / 3;
        positions.push(centerX, boxHeight, centerZ);
        normals.push(0, 1, 0);
        uvs.push(0.5, 0.5);

        // Add cap faces
        for (let i = 0; i < segments; i++) {
            const current = i * 2;
            const next = ((i + 1) % segments) * 2;
            // Bottom cap
            indices.push(bottomCenterIndex, current, next);
            // Top cap
            indices.push(topCenterIndex, next + 1, current + 1);
        }
    } else {
        // Original hollow room code
        for (let i = 0; i <= segments; i++) {
            const theta = (i / segments) * Math.PI * 2;
            const x = centerX + radius * Math.cos(theta);
            const z = centerZ + radius * Math.sin(theta);

            positions.push(x, 0, z);
            positions.push(x, boxHeight, z);

            const normal = [Math.cos(theta), 0, Math.sin(theta)];
            normals.push(...normal, ...normal);

            uvs.push(i / segments, 0, i / segments, 1);
        }

        for (let i = 0; i < segments; i++) {
            const base = i * 2;
            indices.push(
                base, base + 1, base + 2,
                base + 1, base + 3, base + 2
            );
        }
    }
    break;
}

              case "polygon": {
                if (!room.points || room.points.length < 3) return null;

                const baseZ = room.bounds.y / 50 - boxDepth / 2;
                const baseX = room.bounds.x / 50 - boxWidth / 2;

                if (isWall) {
                  // Calculate scaling like rectangle case
                  const heightRatio = 1.0;
                  const scaleU = wallTexture
                    ? room.bounds.width / wallTextureRoom.bounds.width
                    : 1;
                  const scaleV = wallTexture
                    ? heightRatio * (boxHeight / wallTextureRoom.bounds.height)
                    : 1;

                  // Use texture repeats for vertical surfaces
                  const textureRepeatsU = wallTexture
                    ? wallTexture.repeat.x
                    : 1;
                  const textureRepeatsV = wallTexture
                    ? wallTexture.repeat.y
                    : 1;

                  // Create points for the walls
                  for (let i = 0; i < room.points.length; i++) {
                    const point = room.points[i];
                    const nextPoint = room.points[(i + 1) % room.points.length];
                    const x1 = point.x / 50 + baseX;
                    const z1 = point.y / 50 + baseZ;
                    const x2 = nextPoint.x / 50 + baseX;
                    const z2 = nextPoint.y / 50 + baseZ;

                    // Add vertices for this wall segment
                    positions.push(
                      x1,
                      0,
                      z1, // bottom left
                      x2,
                      0,
                      z2, // bottom right
                      x2,
                      boxHeight,
                      z2, // top right
                      x1,
                      boxHeight,
                      z1 // top left
                    );

                    // Calculate wall segment length for UV scaling
                    const segmentLength = Math.sqrt(
                      Math.pow(x2 - x1, 2) + Math.pow(z2 - z1, 2)
                    );
                    const segmentScaleU =
                      (segmentLength / (wallTextureRoom.bounds.width / 50)) *
                      textureRepeatsU;

                    // Add UVs for this segment, incorporating texture repeats
                    uvs.push(
                      0,
                      0, // bottom left
                      segmentScaleU,
                      0, // bottom right
                      segmentScaleU,
                      textureRepeatsV, // top right
                      0,
                      textureRepeatsV // top left
                    );

                    // Add normals
                    const dx = x2 - x1;
                    const dz = z2 - z1;
                    const length = Math.sqrt(dx * dx + dz * dz);
                    const nx = dz / length;
                    const nz = -dx / length;

                    for (let j = 0; j < 4; j++) {
                      normals.push(nx, 0, nz);
                    }

                    // Add indices for this segment
                    const base = i * 4;
                    indices.push(
                      base,
                      base + 1,
                      base + 2,
                      base,
                      base + 2,
                      base + 3
                    );
                  }
                } else {
                  // Original hollow room code
                  room.points.forEach((point, i) => {
                    const x = point.x / 50 + baseX;
                    const z = point.y / 50 + baseZ;

                    positions.push(x, 0, z);
                    positions.push(x, boxHeight, z);

                    normals.push(0, 0, 1, 0, 0, 1);

                    uvs.push(i / room.points.length, 0);
                    uvs.push(i / room.points.length, 1);
                  });

                  for (let i = 0; i < room.points.length; i++) {
                    const next = (i + 1) % room.points.length;
                    const base = i * 2;
                    const nextBase = next * 2;

                    indices.push(
                      base,
                      base + 1,
                      nextBase,
                      base + 1,
                      nextBase + 1,
                      nextBase
                    );
                  }
                }
                break;
              }

              default: {
                // rectangle
                const x1 = room.bounds.x / 50 - boxWidth / 2;
                const x2 = x1 + room.bounds.width / 50;
                const z1 = room.bounds.y / 50 - boxDepth / 2;
                const z2 = z1 + room.bounds.height / 50;

                if (isWall) {
                  // Create solid box vertices
                  positions.push(
                    // Bottom face
                    x1,
                    0,
                    z1,
                    x2,
                    0,
                    z1,
                    x2,
                    0,
                    z2,
                    x1,
                    0,
                    z2,
                    // Top face
                    x1,
                    boxHeight,
                    z1,
                    x2,
                    boxHeight,
                    z1,
                    x2,
                    boxHeight,
                    z2,
                    x1,
                    boxHeight,
                    z2,
                    // Front and back
                    x1,
                    0,
                    z1,
                    x2,
                    0,
                    z1,
                    x2,
                    boxHeight,
                    z1,
                    x1,
                    boxHeight,
                    z1,
                    x1,
                    0,
                    z2,
                    x2,
                    0,
                    z2,
                    x2,
                    boxHeight,
                    z2,
                    x1,
                    boxHeight,
                    z2,
                    // Left and right
                    x1,
                    0,
                    z1,
                    x1,
                    0,
                    z2,
                    x1,
                    boxHeight,
                    z2,
                    x1,
                    boxHeight,
                    z1,
                    x2,
                    0,
                    z1,
                    x2,
                    0,
                    z2,
                    x2,
                    boxHeight,
                    z2,
                    x2,
                    boxHeight,
                    z1
                  );

                  // Add corresponding normals for each face
                  for (let i = 0; i < 4; i++) normals.push(0, -1, 0); // Bottom
                  for (let i = 0; i < 4; i++) normals.push(0, 1, 0); // Top
                  for (let i = 0; i < 4; i++) normals.push(0, 0, -1); // Front
                  for (let i = 0; i < 4; i++) normals.push(0, 0, 1); // Back
                  for (let i = 0; i < 4; i++) normals.push(-1, 0, 0); // Left
                  for (let i = 0; i < 4; i++) normals.push(1, 0, 0); // Right

                  const heightRatio = 1.0;
                  const scaleU = wallTexture
                    ? room.bounds.width / wallTextureRoom.bounds.width
                    : 1;
                  const scaleV = wallTexture
                    ? heightRatio * (boxHeight / wallTextureRoom.bounds.height)
                    : 1;

                  // Get texture repeats
                  const textureRepeatsU = wallTexture
                    ? wallTexture.repeat.x
                    : 1;
                  const textureRepeatsV = wallTexture
                    ? wallTexture.repeat.y
                    : 1;

                  // Bottom face
                  uvs.push(
                    0,
                    0,
                    textureRepeatsU,
                    0,
                    textureRepeatsU,
                    textureRepeatsU,
                    0,
                    textureRepeatsU
                  );
                  // Top face
                  uvs.push(
                    0,
                    0,
                    textureRepeatsU,
                    0,
                    textureRepeatsU,
                    textureRepeatsU,
                    0,
                    textureRepeatsU
                  );

                  // Front face (use width for U repeat)
                  const widthRepeats =
                    (Math.abs(x2 - x1) / (wallTextureRoom.bounds.width / 50)) *
                    textureRepeatsU;
                  uvs.push(
                    0,
                    0,
                    widthRepeats,
                    0,
                    widthRepeats,
                    textureRepeatsV,
                    0,
                    textureRepeatsV
                  );
                  // Back face
                  uvs.push(
                    0,
                    0,
                    widthRepeats,
                    0,
                    widthRepeats,
                    textureRepeatsV,
                    0,
                    textureRepeatsV
                  );

                  // Left face (use depth for U repeat)
                  const depthRepeats =
                    (Math.abs(z2 - z1) / (wallTextureRoom.bounds.width / 50)) *
                    textureRepeatsU;
                  uvs.push(
                    0,
                    0,
                    depthRepeats,
                    0,
                    depthRepeats,
                    textureRepeatsV,
                    0,
                    textureRepeatsV
                  );
                  // Right face
                  uvs.push(
                    0,
                    0,
                    depthRepeats,
                    0,
                    depthRepeats,
                    textureRepeatsV,
                    0,
                    textureRepeatsV
                  );

                  // Add indices for each face (6 faces, 2 triangles each)
                  for (let face = 0; face < 6; face++) {
                    const base = face * 4;
                    indices.push(
                      base,
                      base + 1,
                      base + 2,
                      base,
                      base + 2,
                      base + 3
                    );
                  }
                } else {
                  // Original hollow room code
                  const wallVertices = [
                    x1,
                    0,
                    z1,
                    x1,
                    boxHeight,
                    z1,
                    x2,
                    boxHeight,
                    z1,
                    x2,
                    0,
                    z1,
                    x1,
                    0,
                    z2,
                    x2,
                    0,
                    z2,
                    x2,
                    boxHeight,
                    z2,
                    x1,
                    boxHeight,
                    z2,
                    x1,
                    0,
                    z1,
                    x1,
                    0,
                    z2,
                    x1,
                    boxHeight,
                    z2,
                    x1,
                    boxHeight,
                    z1,
                    x2,
                    0,
                    z1,
                    x2,
                    boxHeight,
                    z1,
                    x2,
                    boxHeight,
                    z2,
                    x2,
                    0,
                    z2
                  ];
                  positions.push(...wallVertices);

                  for (let i = 0; i < 4; i++) {
                    const base = i * 4;
                    indices.push(
                      base,
                      base + 1,
                      base + 2,
                      base,
                      base + 2,
                      base + 3
                    );
                  }

                  for (let i = 0; i < wallVertices.length / 3; i++) {
                    normals.push(0, 0, 1);
                    uvs.push(i % 2, Math.floor(i / 2) % 2);
                  }
                }
                break;
              }
            }

            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute(
              "position",
              new THREE.Float32BufferAttribute(positions, 3)
            );
            geometry.setAttribute(
              "normal",
              new THREE.Float32BufferAttribute(normals, 3)
            );
            geometry.setAttribute(
              "uv",
              new THREE.Float32BufferAttribute(uvs, 2)
            );
            geometry.setIndex(indices);




    const material = room.type === "wall"
    ? this.textureManager.createMaterial(room, wallTextureRoom)
    : this.textureManager.createMaterial(room, roomTextureRoom);

            return new THREE.Mesh(geometry, material);
          };

          // Create materials
          const materials = [
            new THREE.MeshStandardMaterial({
              map: texture,
              side: THREE.DoubleSide
            }),
            new THREE.MeshStandardMaterial({
              color: 0x808080,
              roughness: 0.7,
              side: THREE.DoubleSide
            })
          ];



          // Create rooms and subtract from main mesh
        const createRaisedBlockGeometry = (room) => {
        let geometry;
        const materials = [];
        
        // Side material (using wall texture)
        const sideMaterial = room.type === "wall" ?
            this.textureManager.createMaterial(room, wallTextureRoom) :
            new THREE.MeshStandardMaterial({
                color: 0xcccccc,
                roughness: 0.7,
                metalness: 0.2,
                side: THREE.DoubleSide
            });
        materials.push(sideMaterial);
        // Create and configure top texture
        const topTexture = this.createTextureFromArea(room);
        topTexture.center.set(0.5, 0.5); // Set rotation center to middle
        // Remove the rotation line
        topTexture.repeat.set(1, 1); // Ensure 1:1 mapping
        topTexture.needsUpdate = true;

        // Create top material with the configured texture
        const topMaterial = new THREE.MeshStandardMaterial({
            map: topTexture,
            roughness: 0.6,
            metalness: 0.1,
            side: THREE.DoubleSide
        });
        materials.push(topMaterial);
    
        // Bottom material (use same as sides)
        materials.push(sideMaterial);
    

    switch(room.shape) {

case "circle": {
        topTexture.rotation = Math.PI / 2; 

   topTexture.needsUpdate = true;
    const radius = Math.max(room.bounds.width, room.bounds.height) / 100;
    geometry = new THREE.CylinderGeometry(radius, radius, room.blockHeight, 32);
    geometry.rotateZ(0);  // Keep it horizontal
    break;
}



case "polygon": {
    if (!room.points || room.points.length < 3) return null;

    // Swap materials first
    const tempMaterial = materials[0];
    materials[0] = materials[1];
    materials[1] = tempMaterial;

    const shape = new THREE.Shape();
    
    // Calculate bounds for UV mapping
    const minX = Math.min(...room.points.map(p => p.x));
    const maxX = Math.max(...room.points.map(p => p.x));
    const minY = Math.min(...room.points.map(p => p.y));
    const maxY = Math.max(...room.points.map(p => p.y));
    const width = maxX - minX;
    const height = maxY - minY;

    // Create shape with normalized coordinates
    room.points.forEach((point, index) => {
        const x = (point.x - minX) / 50;
        const y = -(point.y - minY) / 50;  // Flip Y and normalize
        if (index === 0) shape.moveTo(x, y);
        else shape.lineTo(x, y);
    });
    shape.closePath();

    geometry = new THREE.ExtrudeGeometry(shape, {
        depth: room.blockHeight,
        bevelEnabled: false,
        UVGenerator: {
            generateTopUV: function(geometry, vertices, indexA, indexB, indexC) {
                const vA = new THREE.Vector3(vertices[indexA * 3], vertices[indexA * 3 + 1], vertices[indexA * 3 + 2]);
                const vB = new THREE.Vector3(vertices[indexB * 3], vertices[indexB * 3 + 1], vertices[indexB * 3 + 2]);
                const vC = new THREE.Vector3(vertices[indexC * 3], vertices[indexC * 3 + 1], vertices[indexC * 3 + 2]);

                return [
                    new THREE.Vector2(vA.x / width * 50, vA.y / height * 50),
                    new THREE.Vector2(vB.x / width * 50, vB.y / height * 50),
                    new THREE.Vector2(vC.x / width * 50, vC.y / height * 50)
                ];
            },
            generateSideWallUV: function(geometry, vertices, indexA, indexB, indexC, indexD) {
                return [
                    new THREE.Vector2(0, 0),
                    new THREE.Vector2(1, 0),
                    new THREE.Vector2(1, 1),
                    new THREE.Vector2(0, 1)
                ];
            }
        }
    });

    geometry.rotateX(-Math.PI / 2);
    
    // Remove the translate line - let mesh positioning handle it
    // geometry.translate(minX / 50, 0, minY / 50);

    const topBottomFaces = room.points.length - 2;
    const sideFaces = room.points.length * 2;
    
    geometry.clearGroups();
    geometry.addGroup(0, sideFaces * 3, 0);
    geometry.addGroup(sideFaces * 3, topBottomFaces * 3, 1);
    geometry.addGroup((sideFaces + topBottomFaces) * 3, topBottomFaces * 3, 2);

    break;
}

default: {
    // Rectangle case
    const positions = [];
    const normals = [];
    const uvs = [];
    const indices = [];
    // Keep track of where each face starts for material mapping
    const materialGroups = [];
    let faceCount = 0;

    const x1 = room.bounds.x / 50 - boxWidth / 2;
    const x2 = x1 + room.bounds.width / 50;
    const z1 = room.bounds.y / 50 - boxDepth / 2;
    const z2 = z1 + room.bounds.height / 50;
    const height = room.blockHeight;

    // Create and configure top texture
    topTexture.repeat.set(1, -1);  // Flip vertically by setting Y to negative
        topTexture.needsUpdate = true;

    // All vertices remain the same
    positions.push(
        // Bottom face
        x1, 0, z1,
        x2, 0, z1,
        x2, 0, z2,
        x1, 0, z2,
        // Top face
        x1, height, z1,
        x2, height, z1,
        x2, height, z2,
        x1, height, z2,
        // Front
        x1, 0, z1,
        x2, 0, z1,
        x2, height, z1,
        x1, height, z1,
        // Back
        x1, 0, z2,
        x2, 0, z2,
        x2, height, z2,
        x1, height, z2,
        // Left
        x1, 0, z1,
        x1, 0, z2,
        x1, height, z2,
        x1, height, z1,
        // Right
        x2, 0, z1,
        x2, 0, z2,
        x2, height, z2,
        x2, height, z1
    );

    // Normals stay the same
    for (let i = 0; i < 4; i++) normals.push(0, -1, 0);  // Bottom
    for (let i = 0; i < 4; i++) normals.push(0, 1, 0);   // Top
    for (let i = 0; i < 4; i++) normals.push(0, 0, -1);  // Front
    for (let i = 0; i < 4; i++) normals.push(0, 0, 1);   // Back
    for (let i = 0; i < 4; i++) normals.push(-1, 0, 0);  // Left
    for (let i = 0; i < 4; i++) normals.push(1, 0, 0);   // Right

    // UVs for each face
    const textureRepeatsU = wallTexture ? wallTexture.repeat.x : 1;
    const textureRepeatsV = wallTexture ? wallTexture.repeat.y : 1;

    // Add UVs for each face
    for (let face = 0; face < 6; face++) {
        uvs.push(
            0, 0,
            textureRepeatsU, 0,
            textureRepeatsU, textureRepeatsV,
            0, textureRepeatsV
        );
    }

    // Add indices with material groups
    // Bottom face (material index 2)
    materialGroups.push({ startIndex: faceCount * 3, count: 6, materialIndex: 2 });
    indices.push(0, 1, 2, 0, 2, 3);
    faceCount += 2;

    // Top face (material index 1)
    materialGroups.push({ startIndex: faceCount * 3, count: 6, materialIndex: 1 });
    indices.push(4, 5, 6, 4, 6, 7);
    faceCount += 2;

    // Side faces (material index 0)
    materialGroups.push({ startIndex: faceCount * 3, count: 24, materialIndex: 0 });
    for (let face = 2; face < 6; face++) {
        const base = face * 4;
        indices.push(
            base, base + 1, base + 2,
            base, base + 2, base + 3
        );
        faceCount += 2;
    }

    geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
    geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    geometry.setIndex(indices);

    // Add material groups to geometry
    materialGroups.forEach(group => {
        geometry.addGroup(group.startIndex, group.count, group.materialIndex);
    });

    break;
}
    }

    const mesh = new THREE.Mesh(geometry, materials);

// Position mesh correctly based on room bounds
if (room.shape === "polygon") {
    // mesh.position.set(
    //     (room.bounds.x + room.bounds.width/2) / 50 - boxWidth / 2,
    //     0,
    //     (room.bounds.y + room.bounds.height/2) / 50 - boxDepth / 2
    // );

    mesh.position.set(
        room.bounds.x / 50 - boxWidth / 2,  // Use absolute position
        0,
        room.bounds.y / 50 - boxDepth / 2
    );
} else if (room.shape === "circle") {
    mesh.position.set(
        (room.bounds.x + room.bounds.width/2) / 50 - boxWidth / 2,
        0,
        (room.bounds.y + room.bounds.height/2) / 50 - boxDepth / 2
    );
} else {
  mesh.position.set(0, 0, 0);
}

    return mesh;
};



          updateStatus(20);
this.rooms.forEach((room, index) => {
    // Skip the WallTexture room in 3D view
    if (room.name === "WallTexture" || room.name === "RoomTexture") {
        return;
    }

    let roomMesh;
    if (room.isRaisedBlock && room.blockHeight) {
        roomMesh = createRaisedBlockGeometry(room);
        if (roomMesh) {
            roomMesh.userData.isWall = true;
        }
    } else {
        roomMesh = createRoomGeometry(room);
        if (roomMesh) {
            roomMesh.userData.isWall = room.type === "wall";
        }
    }

    if (roomMesh) {
        if (roomMesh.userData.isWall) {
            // console.log("Creating wall mesh:", {
            //     roomName: room.name,
            //     hasTexture: !!roomMesh.material.map,
            //     isTransparent: roomMesh.material.transparent,
            //     opacity: roomMesh.material.opacity
            // });
        }
        scene.add(roomMesh);
    }
    updateStatus(20 + 60 * (index / this.rooms.length));
});


          // Add floor
          const floorGeometry = new THREE.PlaneGeometry(boxWidth, boxDepth);
          const floor = new THREE.Mesh(floorGeometry, materials[0]);
          floor.rotation.x = -Math.PI / 2;
          floor.position.y = 0.01; // Slightly above ground to prevent z-fighting
          scene.add(floor);

          // Add lighting
          const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
          scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(5, 10, 5);
          directionalLight.castShadow = true;
          scene.add(directionalLight);

          // Position camera at player start if available
          if (this.playerStart) {
            camera.position.set(
              this.playerStart.x / 50 - boxWidth / 2,
              1.7, // Eye level
              this.playerStart.y / 50 - boxDepth / 2
            );
          }


    //     if (this.tokens && this.tokens.length > 0) {
    // console.log("Creating 3D tokens:", this.tokens);
    // this.tokens.forEach((token) => {
    //     const textureLoader = new THREE.TextureLoader();
    //     textureLoader.load(
    //         token.image,
    //         (texture) => {
    //             console.log("Token texture loaded:", texture);

    //             const spriteMaterial = new THREE.SpriteMaterial({
    //                 map: texture,  // Add this line - it was missing
    //                 sizeAttenuation: true
    //             });

    //             const sprite = new THREE.Sprite(spriteMaterial);
    //             const scale = token.size * (this.cellSize / 25);
    //             const aspectRatio = texture.image.width / texture.image.height;
    //             sprite.scale.set(scale * aspectRatio, scale, 1);

    //             // Position at grid location - FIXED HEIGHT CALCULATION
    //             const x = token.x / 50 - boxWidth / 2;
    //             const z = token.y / 50 - boxDepth / 2;
    //             const y = token.size * (this.cellSize / 50); // This is the key change

    //             sprite.position.set(x, y, z);
    //             scene.add(sprite);
    //         },
    //         undefined,
    //         (error) => {
    //             console.error("Error loading token texture:", error);
    //         }
    //     );

    //           // Keep debug box for reference
    //           const debugGeometry = new THREE.BoxGeometry(
    //             token.size * (this.cellSize / 25),
    //             0.1,
    //             token.size * (this.cellSize / 25)
    //           );
    //           const debugMaterial = new THREE.MeshBasicMaterial({
    //             color: 0xff0000,
    //             transparent: true,
    //             opacity: 0.5
    //           });
    //           const debugBox = new THREE.Mesh(debugGeometry, debugMaterial);
    //           debugBox.position.set(
    //             token.x / 50 - boxWidth / 2,
    //             0.05,
    //             token.y / 50 - boxDepth / 2
    //           );
    //           scene.add(debugBox);
    //         });
    //       }

          // Setup controls
          
          const createTokenMesh = (token) => {
    // Debug log the token data
    console.log("Creating token mesh with data:", token);

    return new Promise((resolve, reject) => {
        const textureLoader = new THREE.TextureLoader();
        
        textureLoader.load(
            token.image,
            (texture) => {
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    sizeAttenuation: true
                });

                const sprite = new THREE.Sprite(spriteMaterial);
                const scale = token.size * (this.cellSize / 25);
                const aspectRatio = texture.image.width / texture.image.height;
                sprite.scale.set(scale * aspectRatio, scale, 1);

                // Position at grid location
                const x = token.x / 50 - boxWidth / 2;
                const z = token.y / 50 - boxDepth / 2;
                const y = token.size * (this.cellSize / 50); // Height adjustment

                sprite.position.set(x, y, z);
                
                console.log("Token sprite created:", {
                    position: sprite.position,
                    scale: sprite.scale,
                    aspectRatio
                });

                resolve(sprite);
            },
            undefined,
            (error) => {
                console.error("Error loading token texture:", error);
                reject(error);
            }
        );
    });
};

// Then when creating tokens:
if (this.tokens && this.tokens.length > 0) {
    console.log("Processing tokens for 3D view:", this.tokens);
    
    Promise.all(this.tokens.map(token => createTokenMesh(token)))
        .then(sprites => {
            sprites.forEach(sprite => scene.add(sprite));
            console.log("All token sprites added to scene");
        })
        .catch(error => {
            console.error("Error creating token sprites:", error);
        });
}
          
          
          const controls = new THREE.PointerLockControls(
            camera,
            renderer.domElement
          );

          const moveState = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            speed: 0.025,
            sprint: false,
            mouseRightDown: false
          };

          renderer.domElement.addEventListener("contextmenu", (e) => {
            e.preventDefault(); // Prevent right-click menu
          });

          renderer.domElement.addEventListener("mousedown", (e) => {
            if (e.button === 2) {
              // Right mouse button
              moveState.mouseRightDown = true;
              moveState.sprint = true;
              moveState.speed = 0.05;
            }
          });

          renderer.domElement.addEventListener("mouseup", (e) => {
            if (e.button === 2) {
              moveState.mouseRightDown = false;
              // Only disable sprint if Shift is not held
              if (!moveState.shiftHeld) {
                moveState.sprint = false;
                moveState.speed = 0.025;
              }
            }
          });

          const handleKeyDown = (event) => {
            switch (event.code) {
              case "ArrowUp":
              case "KeyW":
                moveState.forward = true;
                break;
              case "ArrowDown":
              case "KeyS":
                moveState.backward = true;
                break;
              case "ArrowLeft":
              case "KeyA":
                moveState.left = true;
                break;
              case "ArrowRight":
              case "KeyD":
                moveState.right = true;
                break;
              case "ShiftLeft":
                moveState.shiftHeld = true;
                moveState.sprint = true;
                moveState.speed = 0.05;
                break;
              case "KeyC":
                if (!event.repeat) {
                  renderState.clippingEnabled = !renderState.clippingEnabled;
                  // Update all wall materials
                  scene.traverse((object) => {
                    if (object.material && object.userData.isWall) {
                      object.material.transparent =
                        !renderState.clippingEnabled;
                      object.material.opacity = renderState.clippingEnabled
                        ? 1.0
                        : 0.8;
                      object.material.side = renderState.clippingEnabled
                        ? THREE.FrontSide
                        : THREE.DoubleSide;
                      object.material.needsUpdate = true;
                    }
                  });
                }
                break;
            }
          };

          const handleKeyUp = (event) => {
            switch (event.code) {
              case "ArrowUp":
              case "KeyW":
                moveState.forward = false;
                break;
              case "ArrowDown":
              case "KeyS":
                moveState.backward = false;
                break;
              case "ArrowLeft":
              case "KeyA":
                moveState.left = false;
                break;
              case "ArrowRight":
              case "KeyD":
                moveState.right = false;
                break;
              case "ShiftLeft":
                moveState.shiftHeld = false;
                // Only disable sprint if right mouse is not held
                if (!moveState.mouseRightDown) {
                  moveState.sprint = false;
                  moveState.speed = 0.025;
                }
                break;
            }
          };

          document.addEventListener("keydown", handleKeyDown);
          document.addEventListener("keyup", handleKeyUp);

          // Lock/unlock controls
          renderer.domElement.addEventListener("click", () => {
            controls.lock();
          });

          controls.addEventListener("lock", () => {
            renderer.domElement.style.cursor = "none";
          });

          controls.addEventListener("unlock", () => {
            renderer.domElement.style.cursor = "auto";
          });

          updateStatus(100);

          // Animation loop
          const animate = () => {
            const currentSpeed = moveState.speed;

            // Handle movement
            if (moveState.forward) controls.moveForward(currentSpeed);
            if (moveState.backward) controls.moveForward(-currentSpeed);
            if (moveState.left) controls.moveRight(-currentSpeed);
            if (moveState.right) controls.moveRight(currentSpeed);

            // Keep player at constant height (no jumping/falling)
            camera.position.y = 1.7;

            // Render the scene
            renderer.render(scene, camera);
          };

          // Return all necessary objects and cleanup function
          return {
            scene,
            camera,
            renderer,
            animate,
            controls,
            cleanup: () => {
              // Remove event listeners
              document.removeEventListener("keydown", handleKeyDown);
              document.removeEventListener("keyup", handleKeyUp);

              // Dispose of renderer
              renderer.dispose();

              // Dispose of geometries and materials
              scene.traverse((object) => {
                if (object.geometry) {
                  object.geometry.dispose();
                }
                if (object.material) {
                  if (Array.isArray(object.material)) {
                    object.material.forEach((material) => material.dispose());
                  } else {
                    object.material.dispose();
                  }
                }
              });
            }
          };
        }

        setupDrawer() {
    const drawer = document.createElement("sl-drawer");
    drawer.label = "3D View";
    drawer.placement = "end";
    drawer.classList.add("drawer-3d-view");

    // Calculate width based on viewport and sidebar
    const sidebar = document.querySelector(".sidebar");
    const sidebarWidth = sidebar ? sidebar.offsetWidth : 0;
    const availableWidth = window.innerWidth - sidebarWidth;
    const drawerWidth = `${Math.floor(availableWidth)}px`; // Use pixels instead of vw

    // Set drawer width
    drawer.style.setProperty("--size", drawerWidth);

    // Container for Three.js
    const container = document.createElement("div");
    container.style.width = "100%";
    container.style.height = "100%";
    container.style.overflow = "hidden"; // Prevent scrollbars
    drawer.appendChild(container);

    // Progress indicator
    const progress = document.createElement("sl-progress-bar");
    progress.style.display = "none";
    drawer.appendChild(progress);

    document.body.appendChild(drawer);
    return { drawer, container, progress };
}

async show3DView() {
    const { drawer, container, progress } = this.setupDrawer();

    progress.style.display = "block";
    progress.value = 0;

    const updateStatus = (percent) => {
        progress.value = percent;
        progress.innerHTML = `Processing... ${Math.round(percent)}%`;
    };

    try {
        drawer.show();
        const { scene, camera, renderer, animate, controls, cleanup } = await this.init3DScene(updateStatus);

        // Calculate available width for renderer
        const sidebar = document.querySelector(".sidebar");
        const sidebarWidth = sidebar ? sidebar.offsetWidth : 0;
        const availableWidth = window.innerWidth - sidebarWidth;
        
        // Set renderer size
        renderer.setSize(availableWidth, window.innerHeight);
        
        // Update camera aspect ratio
        camera.aspect = availableWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        container.appendChild(renderer.domElement);

        // Instructions overlay
        const instructions = document.createElement("div");
        instructions.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 20px;
            width: 75vw;
            border-radius: 5px;
            text-align: center;
            pointer-events: none;
        `;
        instructions.innerHTML = `
            Click to start<br>
            WASD or Arrow Keys to move<br>
            Hold Shift to sprint<br>
            C to toggle wall clipping<br>
            ESC to exit
        `;
        container.appendChild(instructions);

        // Hide instructions when controls are locked
        controls.addEventListener("lock", () => {
            instructions.style.display = "none";
        });

        controls.addEventListener("unlock", () => {
            instructions.style.display = "block";
        });

        // Animation loop that respects drawer state
        let animationFrameId;
        const animationLoop = () => {
            if (drawer.open) {
                animationFrameId = requestAnimationFrame(animationLoop);
                animate();
            }
        };
        animationLoop();

        // Handle window resize
        const handleResize = () => {
            const sidebar = document.querySelector(".sidebar");
            const sidebarWidth = sidebar ? sidebar.offsetWidth : 0;
            const availableWidth = window.innerWidth - sidebarWidth;
            
            renderer.setSize(availableWidth, window.innerHeight);
            camera.aspect = availableWidth / window.innerHeight;
            camera.updateProjectionMatrix();
        };

        window.addEventListener('resize', handleResize);

        // Cleanup when drawer closes
        drawer.addEventListener("sl-after-hide", () => {
            cancelAnimationFrame(animationFrameId);
            window.removeEventListener('resize', handleResize);
            cleanup();
            container.innerHTML = "";
        }, { once: true });

    } catch (error) {
        console.error("Error creating 3D view:", error);
        container.innerHTML = `
            <div style="color: red; padding: 20px;">
                Error creating 3D view: ${error.message}
            </div>
        `;
    } finally {
        progress.style.display = "none";
    }
}

        createRoomShape(room) {
          let geometry;

          switch (room.shape) {
            case "circle":
              const radius =
                Math.max(room.bounds.width, room.bounds.height) / 100;
              geometry = new THREE.CylinderGeometry(radius, radius, 4, 32);
              break;

            case "polygon":
              if (!room.points || room.points.length < 3) return null;

              const shape = new THREE.Shape();
              room.points.forEach((point, index) => {
                const x = point.x / 50;
                const y = point.y / 50;
                if (index === 0) shape.moveTo(x, y);
                else shape.lineTo(x, y);
              });
              shape.closePath();

              geometry = new THREE.ExtrudeGeometry(shape, {
                depth: 4,
                bevelEnabled: false
              });
              break;

            default: // rectangle
              geometry = new THREE.BoxGeometry(
                room.bounds.width / 50,
                4,
                room.bounds.height / 50
              );
          }

          const material = new THREE.MeshStandardMaterial({
            color: 0x808080,
            side: THREE.DoubleSide,
            transparent: true,
            opacity: 0.0 // Make it invisible
          });

          const mesh = new THREE.Mesh(geometry, material);

          // Position the room correctly
          mesh.position.set(
            room.bounds.x / 50,
            2, // Half of height
            room.bounds.y / 50
          );

          return mesh;
        }

        async processRooms(scene, mainBox, updateStatus) {
          let result = mainBox;
          const totalRooms = this.rooms.length;

          for (let i = 0; i < totalRooms; i++) {
            const room = this.rooms[i];
            const roomMesh = this.createRoomShape(room);

            if (roomMesh) {
              try {
                // Perform CSG subtraction
                const bspA = CSG.fromMesh(result);
                const bspB = CSG.fromMesh(roomMesh);
                const bspResult = bspA.subtract(bspB);
                result = CSG.toMesh(bspResult, result.matrix, result.material);
              } catch (error) {
                console.error(`Error processing room ${room.id}:`, error);
              }
            }

            if (updateStatus) {
              updateStatus(20 + 60 * (i / totalRooms));
            }
          }

          scene.add(result);
          return result;
        }

// Add to MapEditor class
async assignTexture(structure, textureData, position = null) {
    if (!structure || !textureData) return null;

    const assignment = {
        id: Date.now(),
        textureId: textureData.id,
        structureId: structure.id,
        structureType: structure.type,
        position: position || null, // For specific placement on walls/rooms
        dateAssigned: new Date().toISOString()
    };

    // Initialize texture assignments if needed
    if (!structure.textureAssignments) {
        structure.textureAssignments = new Map();
    }

    structure.textureAssignments.set(assignment.id, assignment);

    // If this is a door texture, handle it specially
    if (textureData.category === 'doors') {
        return this.createDoor(structure, assignment);
    }

    // If this is a prop (like a torch), handle placement
    if (textureData.category === 'props') {
        return this.createProp(structure, assignment);
    }

    return assignment;
}

createProp(structure, assignment) {
    const prop = {
        id: assignment.id,
        parentId: structure.id,
        textureId: assignment.textureId,
        position: assignment.position,
        rotation: 0
    };

    // Add visual representation
    const propElement = document.createElement('div');
    propElement.className = 'prop';
    propElement.style.cssText = `
        position: absolute;
        pointer-events: all;
        cursor: pointer;
        width: ${this.cellSize}px;
        height: ${this.cellSize}px;
    `;

    // Add to structure
    if (!structure.props) structure.props = new Map();
    structure.props.set(prop.id, prop);

    return prop;
}


createTextureFromArea(room) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = room.bounds.width;
    canvas.height = room.bounds.height;

    // Draw the portion of the map that contains the texture
    ctx.drawImage(
        this.baseImage,  // Changed from this.mapEditor.baseImage
        room.bounds.x,
        room.bounds.y,
        room.bounds.width,
        room.bounds.height,
        0,
        0,
        canvas.width,
        canvas.height
    );

    const texture = new THREE.CanvasTexture(canvas);
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    
    return texture;
}


      }

      document.addEventListener("DOMContentLoaded", updateLayersListHeight);

      // Also call it when the window is resized
      window.addEventListener("resize", updateLayersListHeight);

      // Initialize the application
      window.addEventListener("DOMContentLoaded", () => {
        window.mapEditor = new MapEditor();
      });
    </script>
  </body>
</html>